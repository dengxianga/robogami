// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: symbolic.proto

#ifndef PROTOBUF_symbolic_2eproto__INCLUDED
#define PROTOBUF_symbolic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace FabByExample {
namespace proto {
namespace symbolic {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_symbolic_2eproto();
void protobuf_AssignDesc_symbolic_2eproto();
void protobuf_ShutdownFile_symbolic_2eproto();

class Parameter;
class LinearExpr;
class Point2S;
class Point3S;
class Vertex2S;
class Edge2S;
class Face2S;
class Drawing2S;
class Vertex3S;
class Edge3S;
class Face3S;
class Mesh3S;
class AffineMatrix3S;
class Transform;
class Control;
class ControlMappingFunction;
class ParametricPiecewiseLinearFunction;
class GrammarControllerMappingFunction;
class LinearMappingFuction1D;
class PiecewiseLinearFunction1D;
class TimeAndValuePair;
class PWLinear;

enum Transform_TransformType {
  Transform_TransformType_REVOLUTE_TRANSFORM = 1,
  Transform_TransformType_PRISMATIC_TRANSFORM = 2
};
bool Transform_TransformType_IsValid(int value);
const Transform_TransformType Transform_TransformType_TransformType_MIN = Transform_TransformType_REVOLUTE_TRANSFORM;
const Transform_TransformType Transform_TransformType_TransformType_MAX = Transform_TransformType_PRISMATIC_TRANSFORM;
const int Transform_TransformType_TransformType_ARRAYSIZE = Transform_TransformType_TransformType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transform_TransformType_descriptor();
inline const ::std::string& Transform_TransformType_Name(Transform_TransformType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transform_TransformType_descriptor(), value);
}
inline bool Transform_TransformType_Parse(
    const ::std::string& name, Transform_TransformType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transform_TransformType>(
    Transform_TransformType_descriptor(), name, value);
}
enum GrammarControllerMappingFunction_GrammarControllerType {
  GrammarControllerMappingFunction_GrammarControllerType_WHEEL = 1,
  GrammarControllerMappingFunction_GrammarControllerType_LEG = 2,
  GrammarControllerMappingFunction_GrammarControllerType_DOUBLE_SHOULDER = 3,
  GrammarControllerMappingFunction_GrammarControllerType_DOUBLE_ELBOW = 4
};
bool GrammarControllerMappingFunction_GrammarControllerType_IsValid(int value);
const GrammarControllerMappingFunction_GrammarControllerType GrammarControllerMappingFunction_GrammarControllerType_GrammarControllerType_MIN = GrammarControllerMappingFunction_GrammarControllerType_WHEEL;
const GrammarControllerMappingFunction_GrammarControllerType GrammarControllerMappingFunction_GrammarControllerType_GrammarControllerType_MAX = GrammarControllerMappingFunction_GrammarControllerType_DOUBLE_ELBOW;
const int GrammarControllerMappingFunction_GrammarControllerType_GrammarControllerType_ARRAYSIZE = GrammarControllerMappingFunction_GrammarControllerType_GrammarControllerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GrammarControllerMappingFunction_GrammarControllerType_descriptor();
inline const ::std::string& GrammarControllerMappingFunction_GrammarControllerType_Name(GrammarControllerMappingFunction_GrammarControllerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GrammarControllerMappingFunction_GrammarControllerType_descriptor(), value);
}
inline bool GrammarControllerMappingFunction_GrammarControllerType_Parse(
    const ::std::string& name, GrammarControllerMappingFunction_GrammarControllerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GrammarControllerMappingFunction_GrammarControllerType>(
    GrammarControllerMappingFunction_GrammarControllerType_descriptor(), name, value);
}
// ===================================================================

class Parameter : public ::google::protobuf::Message {
 public:
  Parameter();
  virtual ~Parameter();

  Parameter(const Parameter& from);

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();

  void Swap(Parameter* other);

  // implements Message ----------------------------------------------

  Parameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional double default = 3;
  inline bool has_default_() const;
  inline void clear_default_();
  static const int kDefaultFieldNumber = 3;
  inline double default_() const;
  inline void set_default_(double value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Parameter)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_default_();
  inline void clear_has_default_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  double default__;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Parameter* default_instance_;
};
// -------------------------------------------------------------------

class LinearExpr : public ::google::protobuf::Message {
 public:
  LinearExpr();
  virtual ~LinearExpr();

  LinearExpr(const LinearExpr& from);

  inline LinearExpr& operator=(const LinearExpr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearExpr& default_instance();

  void Swap(LinearExpr* other);

  // implements Message ----------------------------------------------

  LinearExpr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinearExpr& from);
  void MergeFrom(const LinearExpr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 parameter_id = 1;
  inline int parameter_id_size() const;
  inline void clear_parameter_id();
  static const int kParameterIdFieldNumber = 1;
  inline ::google::protobuf::int32 parameter_id(int index) const;
  inline void set_parameter_id(int index, ::google::protobuf::int32 value);
  inline void add_parameter_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      parameter_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_parameter_id();

  // repeated double coeff = 2;
  inline int coeff_size() const;
  inline void clear_coeff();
  static const int kCoeffFieldNumber = 2;
  inline double coeff(int index) const;
  inline void set_coeff(int index, double value);
  inline void add_coeff(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      coeff() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_coeff();

  // optional double const = 3;
  inline bool has_const_() const;
  inline void clear_const_();
  static const int kConstFieldNumber = 3;
  inline double const_() const;
  inline void set_const_(double value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.LinearExpr)
 private:
  inline void set_has_const_();
  inline void clear_has_const_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > parameter_id_;
  ::google::protobuf::RepeatedField< double > coeff_;
  double const__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static LinearExpr* default_instance_;
};
// -------------------------------------------------------------------

class Point2S : public ::google::protobuf::Message {
 public:
  Point2S();
  virtual ~Point2S();

  Point2S(const Point2S& from);

  inline Point2S& operator=(const Point2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2S& default_instance();

  void Swap(Point2S* other);

  // implements Message ----------------------------------------------

  Point2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point2S& from);
  void MergeFrom(const Point2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.LinearExpr x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::LinearExpr& x() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_x();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_x();
  inline void set_allocated_x(::FabByExample::proto::symbolic::LinearExpr* x);

  // optional .FabByExample.proto.symbolic.LinearExpr y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline const ::FabByExample::proto::symbolic::LinearExpr& y() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_y();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_y();
  inline void set_allocated_y(::FabByExample::proto::symbolic::LinearExpr* y);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Point2S)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::LinearExpr* x_;
  ::FabByExample::proto::symbolic::LinearExpr* y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Point2S* default_instance_;
};
// -------------------------------------------------------------------

class Point3S : public ::google::protobuf::Message {
 public:
  Point3S();
  virtual ~Point3S();

  Point3S(const Point3S& from);

  inline Point3S& operator=(const Point3S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point3S& default_instance();

  void Swap(Point3S* other);

  // implements Message ----------------------------------------------

  Point3S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point3S& from);
  void MergeFrom(const Point3S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.LinearExpr x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::LinearExpr& x() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_x();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_x();
  inline void set_allocated_x(::FabByExample::proto::symbolic::LinearExpr* x);

  // optional .FabByExample.proto.symbolic.LinearExpr y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline const ::FabByExample::proto::symbolic::LinearExpr& y() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_y();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_y();
  inline void set_allocated_y(::FabByExample::proto::symbolic::LinearExpr* y);

  // optional .FabByExample.proto.symbolic.LinearExpr z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::LinearExpr& z() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_z();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_z();
  inline void set_allocated_z(::FabByExample::proto::symbolic::LinearExpr* z);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Point3S)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::LinearExpr* x_;
  ::FabByExample::proto::symbolic::LinearExpr* y_;
  ::FabByExample::proto::symbolic::LinearExpr* z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Point3S* default_instance_;
};
// -------------------------------------------------------------------

class Vertex2S : public ::google::protobuf::Message {
 public:
  Vertex2S();
  virtual ~Vertex2S();

  Vertex2S(const Vertex2S& from);

  inline Vertex2S& operator=(const Vertex2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vertex2S& default_instance();

  void Swap(Vertex2S* other);

  // implements Message ----------------------------------------------

  Vertex2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vertex2S& from);
  void MergeFrom(const Vertex2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .FabByExample.proto.symbolic.Point2S point = 3;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::Point2S& point() const;
  inline ::FabByExample::proto::symbolic::Point2S* mutable_point();
  inline ::FabByExample::proto::symbolic::Point2S* release_point();
  inline void set_allocated_point(::FabByExample::proto::symbolic::Point2S* point);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Vertex2S)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_point();
  inline void clear_has_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::FabByExample::proto::symbolic::Point2S* point_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Vertex2S* default_instance_;
};
// -------------------------------------------------------------------

class Edge2S : public ::google::protobuf::Message {
 public:
  Edge2S();
  virtual ~Edge2S();

  Edge2S(const Edge2S& from);

  inline Edge2S& operator=(const Edge2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge2S& default_instance();

  void Swap(Edge2S* other);

  // implements Message ----------------------------------------------

  Edge2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edge2S& from);
  void MergeFrom(const Edge2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 vertex1_id = 3;
  inline bool has_vertex1_id() const;
  inline void clear_vertex1_id();
  static const int kVertex1IdFieldNumber = 3;
  inline ::google::protobuf::int32 vertex1_id() const;
  inline void set_vertex1_id(::google::protobuf::int32 value);

  // optional int32 vertex2_id = 4;
  inline bool has_vertex2_id() const;
  inline void clear_vertex2_id();
  static const int kVertex2IdFieldNumber = 4;
  inline ::google::protobuf::int32 vertex2_id() const;
  inline void set_vertex2_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Edge2S)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_vertex1_id();
  inline void clear_has_vertex1_id();
  inline void set_has_vertex2_id();
  inline void clear_has_vertex2_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 vertex1_id_;
  ::google::protobuf::int32 vertex2_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Edge2S* default_instance_;
};
// -------------------------------------------------------------------

class Face2S : public ::google::protobuf::Message {
 public:
  Face2S();
  virtual ~Face2S();

  Face2S(const Face2S& from);

  inline Face2S& operator=(const Face2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Face2S& default_instance();

  void Swap(Face2S* other);

  // implements Message ----------------------------------------------

  Face2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Face2S& from);
  void MergeFrom(const Face2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int32 vertex_id = 3;
  inline int vertex_id_size() const;
  inline void clear_vertex_id();
  static const int kVertexIdFieldNumber = 3;
  inline ::google::protobuf::int32 vertex_id(int index) const;
  inline void set_vertex_id(int index, ::google::protobuf::int32 value);
  inline void add_vertex_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vertex_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vertex_id();

  // repeated int32 edge_id = 4;
  inline int edge_id_size() const;
  inline void clear_edge_id();
  static const int kEdgeIdFieldNumber = 4;
  inline ::google::protobuf::int32 edge_id(int index) const;
  inline void set_edge_id(int index, ::google::protobuf::int32 value);
  inline void add_edge_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      edge_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_edge_id();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Face2S)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vertex_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > edge_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Face2S* default_instance_;
};
// -------------------------------------------------------------------

class Drawing2S : public ::google::protobuf::Message {
 public:
  Drawing2S();
  virtual ~Drawing2S();

  Drawing2S(const Drawing2S& from);

  inline Drawing2S& operator=(const Drawing2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Drawing2S& default_instance();

  void Swap(Drawing2S* other);

  // implements Message ----------------------------------------------

  Drawing2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Drawing2S& from);
  void MergeFrom(const Drawing2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .FabByExample.proto.symbolic.Vertex2S vertex = 3;
  inline int vertex_size() const;
  inline void clear_vertex();
  static const int kVertexFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::Vertex2S& vertex(int index) const;
  inline ::FabByExample::proto::symbolic::Vertex2S* mutable_vertex(int index);
  inline ::FabByExample::proto::symbolic::Vertex2S* add_vertex();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Vertex2S >&
      vertex() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Vertex2S >*
      mutable_vertex();

  // repeated .FabByExample.proto.symbolic.Edge2S edge = 4;
  inline int edge_size() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 4;
  inline const ::FabByExample::proto::symbolic::Edge2S& edge(int index) const;
  inline ::FabByExample::proto::symbolic::Edge2S* mutable_edge(int index);
  inline ::FabByExample::proto::symbolic::Edge2S* add_edge();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Edge2S >&
      edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Edge2S >*
      mutable_edge();

  // repeated .FabByExample.proto.symbolic.Face2S face = 5;
  inline int face_size() const;
  inline void clear_face();
  static const int kFaceFieldNumber = 5;
  inline const ::FabByExample::proto::symbolic::Face2S& face(int index) const;
  inline ::FabByExample::proto::symbolic::Face2S* mutable_face(int index);
  inline ::FabByExample::proto::symbolic::Face2S* add_face();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Face2S >&
      face() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Face2S >*
      mutable_face();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Drawing2S)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Vertex2S > vertex_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Edge2S > edge_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Face2S > face_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Drawing2S* default_instance_;
};
// -------------------------------------------------------------------

class Vertex3S : public ::google::protobuf::Message {
 public:
  Vertex3S();
  virtual ~Vertex3S();

  Vertex3S(const Vertex3S& from);

  inline Vertex3S& operator=(const Vertex3S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vertex3S& default_instance();

  void Swap(Vertex3S* other);

  // implements Message ----------------------------------------------

  Vertex3S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vertex3S& from);
  void MergeFrom(const Vertex3S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .FabByExample.proto.symbolic.Point3S point = 3;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::Point3S& point() const;
  inline ::FabByExample::proto::symbolic::Point3S* mutable_point();
  inline ::FabByExample::proto::symbolic::Point3S* release_point();
  inline void set_allocated_point(::FabByExample::proto::symbolic::Point3S* point);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Vertex3S)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_point();
  inline void clear_has_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::FabByExample::proto::symbolic::Point3S* point_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Vertex3S* default_instance_;
};
// -------------------------------------------------------------------

class Edge3S : public ::google::protobuf::Message {
 public:
  Edge3S();
  virtual ~Edge3S();

  Edge3S(const Edge3S& from);

  inline Edge3S& operator=(const Edge3S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge3S& default_instance();

  void Swap(Edge3S* other);

  // implements Message ----------------------------------------------

  Edge3S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edge3S& from);
  void MergeFrom(const Edge3S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 vertex1_id = 3;
  inline bool has_vertex1_id() const;
  inline void clear_vertex1_id();
  static const int kVertex1IdFieldNumber = 3;
  inline ::google::protobuf::int32 vertex1_id() const;
  inline void set_vertex1_id(::google::protobuf::int32 value);

  // optional int32 vertex2_id = 4;
  inline bool has_vertex2_id() const;
  inline void clear_vertex2_id();
  static const int kVertex2IdFieldNumber = 4;
  inline ::google::protobuf::int32 vertex2_id() const;
  inline void set_vertex2_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Edge3S)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_vertex1_id();
  inline void clear_has_vertex1_id();
  inline void set_has_vertex2_id();
  inline void clear_has_vertex2_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 vertex1_id_;
  ::google::protobuf::int32 vertex2_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Edge3S* default_instance_;
};
// -------------------------------------------------------------------

class Face3S : public ::google::protobuf::Message {
 public:
  Face3S();
  virtual ~Face3S();

  Face3S(const Face3S& from);

  inline Face3S& operator=(const Face3S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Face3S& default_instance();

  void Swap(Face3S* other);

  // implements Message ----------------------------------------------

  Face3S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Face3S& from);
  void MergeFrom(const Face3S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int32 vertex_id = 3;
  inline int vertex_id_size() const;
  inline void clear_vertex_id();
  static const int kVertexIdFieldNumber = 3;
  inline ::google::protobuf::int32 vertex_id(int index) const;
  inline void set_vertex_id(int index, ::google::protobuf::int32 value);
  inline void add_vertex_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vertex_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vertex_id();

  // repeated int32 edge_id = 4;
  inline int edge_id_size() const;
  inline void clear_edge_id();
  static const int kEdgeIdFieldNumber = 4;
  inline ::google::protobuf::int32 edge_id(int index) const;
  inline void set_edge_id(int index, ::google::protobuf::int32 value);
  inline void add_edge_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      edge_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_edge_id();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Face3S)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vertex_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > edge_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Face3S* default_instance_;
};
// -------------------------------------------------------------------

class Mesh3S : public ::google::protobuf::Message {
 public:
  Mesh3S();
  virtual ~Mesh3S();

  Mesh3S(const Mesh3S& from);

  inline Mesh3S& operator=(const Mesh3S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mesh3S& default_instance();

  void Swap(Mesh3S* other);

  // implements Message ----------------------------------------------

  Mesh3S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mesh3S& from);
  void MergeFrom(const Mesh3S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline ::google::protobuf::int32 name() const;
  inline void set_name(::google::protobuf::int32 value);

  // repeated .FabByExample.proto.symbolic.Vertex3S vertex = 3;
  inline int vertex_size() const;
  inline void clear_vertex();
  static const int kVertexFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::Vertex3S& vertex(int index) const;
  inline ::FabByExample::proto::symbolic::Vertex3S* mutable_vertex(int index);
  inline ::FabByExample::proto::symbolic::Vertex3S* add_vertex();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Vertex3S >&
      vertex() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Vertex3S >*
      mutable_vertex();

  // repeated .FabByExample.proto.symbolic.Edge3S edge = 4;
  inline int edge_size() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 4;
  inline const ::FabByExample::proto::symbolic::Edge3S& edge(int index) const;
  inline ::FabByExample::proto::symbolic::Edge3S* mutable_edge(int index);
  inline ::FabByExample::proto::symbolic::Edge3S* add_edge();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Edge3S >&
      edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Edge3S >*
      mutable_edge();

  // repeated .FabByExample.proto.symbolic.Face3S face = 5;
  inline int face_size() const;
  inline void clear_face();
  static const int kFaceFieldNumber = 5;
  inline const ::FabByExample::proto::symbolic::Face3S& face(int index) const;
  inline ::FabByExample::proto::symbolic::Face3S* mutable_face(int index);
  inline ::FabByExample::proto::symbolic::Face3S* add_face();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Face3S >&
      face() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Face3S >*
      mutable_face();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Mesh3S)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 name_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Vertex3S > vertex_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Edge3S > edge_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Face3S > face_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Mesh3S* default_instance_;
};
// -------------------------------------------------------------------

class AffineMatrix3S : public ::google::protobuf::Message {
 public:
  AffineMatrix3S();
  virtual ~AffineMatrix3S();

  AffineMatrix3S(const AffineMatrix3S& from);

  inline AffineMatrix3S& operator=(const AffineMatrix3S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AffineMatrix3S& default_instance();

  void Swap(AffineMatrix3S* other);

  // implements Message ----------------------------------------------

  AffineMatrix3S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AffineMatrix3S& from);
  void MergeFrom(const AffineMatrix3S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FabByExample.proto.symbolic.LinearExpr value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::LinearExpr& value(int index) const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_value(int index);
  inline ::FabByExample::proto::symbolic::LinearExpr* add_value();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >&
      value() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.AffineMatrix3S)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static AffineMatrix3S* default_instance_;
};
// -------------------------------------------------------------------

class Transform : public ::google::protobuf::Message {
 public:
  Transform();
  virtual ~Transform();

  Transform(const Transform& from);

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transform& default_instance();

  void Swap(Transform* other);

  // implements Message ----------------------------------------------

  Transform* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Transform_TransformType TransformType;
  static const TransformType REVOLUTE_TRANSFORM = Transform_TransformType_REVOLUTE_TRANSFORM;
  static const TransformType PRISMATIC_TRANSFORM = Transform_TransformType_PRISMATIC_TRANSFORM;
  static inline bool TransformType_IsValid(int value) {
    return Transform_TransformType_IsValid(value);
  }
  static const TransformType TransformType_MIN =
    Transform_TransformType_TransformType_MIN;
  static const TransformType TransformType_MAX =
    Transform_TransformType_TransformType_MAX;
  static const int TransformType_ARRAYSIZE =
    Transform_TransformType_TransformType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransformType_descriptor() {
    return Transform_TransformType_descriptor();
  }
  static inline const ::std::string& TransformType_Name(TransformType value) {
    return Transform_TransformType_Name(value);
  }
  static inline bool TransformType_Parse(const ::std::string& name,
      TransformType* value) {
    return Transform_TransformType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.Control control = 1;
  inline bool has_control() const;
  inline void clear_control();
  static const int kControlFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::Control& control() const;
  inline ::FabByExample::proto::symbolic::Control* mutable_control();
  inline ::FabByExample::proto::symbolic::Control* release_control();
  inline void set_allocated_control(::FabByExample::proto::symbolic::Control* control);

  // optional .FabByExample.proto.symbolic.Point3S axis = 2;
  inline bool has_axis() const;
  inline void clear_axis();
  static const int kAxisFieldNumber = 2;
  inline const ::FabByExample::proto::symbolic::Point3S& axis() const;
  inline ::FabByExample::proto::symbolic::Point3S* mutable_axis();
  inline ::FabByExample::proto::symbolic::Point3S* release_axis();
  inline void set_allocated_axis(::FabByExample::proto::symbolic::Point3S* axis);

  // optional .FabByExample.proto.symbolic.Transform.TransformType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::FabByExample::proto::symbolic::Transform_TransformType type() const;
  inline void set_type(::FabByExample::proto::symbolic::Transform_TransformType value);

  // optional double minVal = 4;
  inline bool has_minval() const;
  inline void clear_minval();
  static const int kMinValFieldNumber = 4;
  inline double minval() const;
  inline void set_minval(double value);

  // optional double maxVal = 5;
  inline bool has_maxval() const;
  inline void clear_maxval();
  static const int kMaxValFieldNumber = 5;
  inline double maxval() const;
  inline void set_maxval(double value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Transform)
 private:
  inline void set_has_control();
  inline void clear_has_control();
  inline void set_has_axis();
  inline void clear_has_axis();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_minval();
  inline void clear_has_minval();
  inline void set_has_maxval();
  inline void clear_has_maxval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::Control* control_;
  ::FabByExample::proto::symbolic::Point3S* axis_;
  double minval_;
  double maxval_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Transform* default_instance_;
};
// -------------------------------------------------------------------

class Control : public ::google::protobuf::Message {
 public:
  Control();
  virtual ~Control();

  Control(const Control& from);

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Control& default_instance();

  void Swap(Control* other);

  // implements Message ----------------------------------------------

  Control* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Control& from);
  void MergeFrom(const Control& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .FabByExample.proto.symbolic.ControlMappingFunction inputs = 3;
  inline bool has_inputs() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::ControlMappingFunction& inputs() const;
  inline ::FabByExample::proto::symbolic::ControlMappingFunction* mutable_inputs();
  inline ::FabByExample::proto::symbolic::ControlMappingFunction* release_inputs();
  inline void set_allocated_inputs(::FabByExample::proto::symbolic::ControlMappingFunction* inputs);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.Control)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_inputs();
  inline void clear_has_inputs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::FabByExample::proto::symbolic::ControlMappingFunction* inputs_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static Control* default_instance_;
};
// -------------------------------------------------------------------

class ControlMappingFunction : public ::google::protobuf::Message {
 public:
  ControlMappingFunction();
  virtual ~ControlMappingFunction();

  ControlMappingFunction(const ControlMappingFunction& from);

  inline ControlMappingFunction& operator=(const ControlMappingFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlMappingFunction& default_instance();

  void Swap(ControlMappingFunction* other);

  // implements Message ----------------------------------------------

  ControlMappingFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlMappingFunction& from);
  void MergeFrom(const ControlMappingFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.LinearMappingFuction1D linear_1 = 1;
  inline bool has_linear_1() const;
  inline void clear_linear_1();
  static const int kLinear1FieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::LinearMappingFuction1D& linear_1() const;
  inline ::FabByExample::proto::symbolic::LinearMappingFuction1D* mutable_linear_1();
  inline ::FabByExample::proto::symbolic::LinearMappingFuction1D* release_linear_1();
  inline void set_allocated_linear_1(::FabByExample::proto::symbolic::LinearMappingFuction1D* linear_1);

  // optional .FabByExample.proto.symbolic.PiecewiseLinearFunction1D piecewiselinear = 2;
  inline bool has_piecewiselinear() const;
  inline void clear_piecewiselinear();
  static const int kPiecewiselinearFieldNumber = 2;
  inline const ::FabByExample::proto::symbolic::PiecewiseLinearFunction1D& piecewiselinear() const;
  inline ::FabByExample::proto::symbolic::PiecewiseLinearFunction1D* mutable_piecewiselinear();
  inline ::FabByExample::proto::symbolic::PiecewiseLinearFunction1D* release_piecewiselinear();
  inline void set_allocated_piecewiselinear(::FabByExample::proto::symbolic::PiecewiseLinearFunction1D* piecewiselinear);

  // optional .FabByExample.proto.symbolic.ParametricPiecewiseLinearFunction piecewiseFunction = 3;
  inline bool has_piecewisefunction() const;
  inline void clear_piecewisefunction();
  static const int kPiecewiseFunctionFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction& piecewisefunction() const;
  inline ::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction* mutable_piecewisefunction();
  inline ::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction* release_piecewisefunction();
  inline void set_allocated_piecewisefunction(::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction* piecewisefunction);

  // optional int32 symbolicController = 4;
  inline bool has_symboliccontroller() const;
  inline void clear_symboliccontroller();
  static const int kSymbolicControllerFieldNumber = 4;
  inline ::google::protobuf::int32 symboliccontroller() const;
  inline void set_symboliccontroller(::google::protobuf::int32 value);

  // optional .FabByExample.proto.symbolic.GrammarControllerMappingFunction grammarFunction = 5;
  inline bool has_grammarfunction() const;
  inline void clear_grammarfunction();
  static const int kGrammarFunctionFieldNumber = 5;
  inline const ::FabByExample::proto::symbolic::GrammarControllerMappingFunction& grammarfunction() const;
  inline ::FabByExample::proto::symbolic::GrammarControllerMappingFunction* mutable_grammarfunction();
  inline ::FabByExample::proto::symbolic::GrammarControllerMappingFunction* release_grammarfunction();
  inline void set_allocated_grammarfunction(::FabByExample::proto::symbolic::GrammarControllerMappingFunction* grammarfunction);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.ControlMappingFunction)
 private:
  inline void set_has_linear_1();
  inline void clear_has_linear_1();
  inline void set_has_piecewiselinear();
  inline void clear_has_piecewiselinear();
  inline void set_has_piecewisefunction();
  inline void clear_has_piecewisefunction();
  inline void set_has_symboliccontroller();
  inline void clear_has_symboliccontroller();
  inline void set_has_grammarfunction();
  inline void clear_has_grammarfunction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::LinearMappingFuction1D* linear_1_;
  ::FabByExample::proto::symbolic::PiecewiseLinearFunction1D* piecewiselinear_;
  ::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction* piecewisefunction_;
  ::FabByExample::proto::symbolic::GrammarControllerMappingFunction* grammarfunction_;
  ::google::protobuf::int32 symboliccontroller_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static ControlMappingFunction* default_instance_;
};
// -------------------------------------------------------------------

class ParametricPiecewiseLinearFunction : public ::google::protobuf::Message {
 public:
  ParametricPiecewiseLinearFunction();
  virtual ~ParametricPiecewiseLinearFunction();

  ParametricPiecewiseLinearFunction(const ParametricPiecewiseLinearFunction& from);

  inline ParametricPiecewiseLinearFunction& operator=(const ParametricPiecewiseLinearFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParametricPiecewiseLinearFunction& default_instance();

  void Swap(ParametricPiecewiseLinearFunction* other);

  // implements Message ----------------------------------------------

  ParametricPiecewiseLinearFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParametricPiecewiseLinearFunction& from);
  void MergeFrom(const ParametricPiecewiseLinearFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FabByExample.proto.symbolic.PWLinear pairs = 1;
  inline int pairs_size() const;
  inline void clear_pairs();
  static const int kPairsFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::PWLinear& pairs(int index) const;
  inline ::FabByExample::proto::symbolic::PWLinear* mutable_pairs(int index);
  inline ::FabByExample::proto::symbolic::PWLinear* add_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::PWLinear >&
      pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::PWLinear >*
      mutable_pairs();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.ParametricPiecewiseLinearFunction)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::PWLinear > pairs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static ParametricPiecewiseLinearFunction* default_instance_;
};
// -------------------------------------------------------------------

class GrammarControllerMappingFunction : public ::google::protobuf::Message {
 public:
  GrammarControllerMappingFunction();
  virtual ~GrammarControllerMappingFunction();

  GrammarControllerMappingFunction(const GrammarControllerMappingFunction& from);

  inline GrammarControllerMappingFunction& operator=(const GrammarControllerMappingFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GrammarControllerMappingFunction& default_instance();

  void Swap(GrammarControllerMappingFunction* other);

  // implements Message ----------------------------------------------

  GrammarControllerMappingFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GrammarControllerMappingFunction& from);
  void MergeFrom(const GrammarControllerMappingFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GrammarControllerMappingFunction_GrammarControllerType GrammarControllerType;
  static const GrammarControllerType WHEEL = GrammarControllerMappingFunction_GrammarControllerType_WHEEL;
  static const GrammarControllerType LEG = GrammarControllerMappingFunction_GrammarControllerType_LEG;
  static const GrammarControllerType DOUBLE_SHOULDER = GrammarControllerMappingFunction_GrammarControllerType_DOUBLE_SHOULDER;
  static const GrammarControllerType DOUBLE_ELBOW = GrammarControllerMappingFunction_GrammarControllerType_DOUBLE_ELBOW;
  static inline bool GrammarControllerType_IsValid(int value) {
    return GrammarControllerMappingFunction_GrammarControllerType_IsValid(value);
  }
  static const GrammarControllerType GrammarControllerType_MIN =
    GrammarControllerMappingFunction_GrammarControllerType_GrammarControllerType_MIN;
  static const GrammarControllerType GrammarControllerType_MAX =
    GrammarControllerMappingFunction_GrammarControllerType_GrammarControllerType_MAX;
  static const int GrammarControllerType_ARRAYSIZE =
    GrammarControllerMappingFunction_GrammarControllerType_GrammarControllerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GrammarControllerType_descriptor() {
    return GrammarControllerMappingFunction_GrammarControllerType_descriptor();
  }
  static inline const ::std::string& GrammarControllerType_Name(GrammarControllerType value) {
    return GrammarControllerMappingFunction_GrammarControllerType_Name(value);
  }
  static inline bool GrammarControllerType_Parse(const ::std::string& name,
      GrammarControllerType* value) {
    return GrammarControllerMappingFunction_GrammarControllerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.GrammarControllerMappingFunction.GrammarControllerType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::FabByExample::proto::symbolic::GrammarControllerMappingFunction_GrammarControllerType type() const;
  inline void set_type(::FabByExample::proto::symbolic::GrammarControllerMappingFunction_GrammarControllerType value);

  // optional double theta = 2;
  inline bool has_theta() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 2;
  inline double theta() const;
  inline void set_theta(double value);

  // optional int32 N_intervals = 3;
  inline bool has_n_intervals() const;
  inline void clear_n_intervals();
  static const int kNIntervalsFieldNumber = 3;
  inline ::google::protobuf::int32 n_intervals() const;
  inline void set_n_intervals(::google::protobuf::int32 value);

  // optional int32 i_interval = 4;
  inline bool has_i_interval() const;
  inline void clear_i_interval();
  static const int kIIntervalFieldNumber = 4;
  inline ::google::protobuf::int32 i_interval() const;
  inline void set_i_interval(::google::protobuf::int32 value);

  // optional double multi = 5;
  inline bool has_multi() const;
  inline void clear_multi();
  static const int kMultiFieldNumber = 5;
  inline double multi() const;
  inline void set_multi(double value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.GrammarControllerMappingFunction)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_theta();
  inline void clear_has_theta();
  inline void set_has_n_intervals();
  inline void clear_has_n_intervals();
  inline void set_has_i_interval();
  inline void clear_has_i_interval();
  inline void set_has_multi();
  inline void clear_has_multi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double theta_;
  int type_;
  ::google::protobuf::int32 n_intervals_;
  double multi_;
  ::google::protobuf::int32 i_interval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static GrammarControllerMappingFunction* default_instance_;
};
// -------------------------------------------------------------------

class LinearMappingFuction1D : public ::google::protobuf::Message {
 public:
  LinearMappingFuction1D();
  virtual ~LinearMappingFuction1D();

  LinearMappingFuction1D(const LinearMappingFuction1D& from);

  inline LinearMappingFuction1D& operator=(const LinearMappingFuction1D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearMappingFuction1D& default_instance();

  void Swap(LinearMappingFuction1D* other);

  // implements Message ----------------------------------------------

  LinearMappingFuction1D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinearMappingFuction1D& from);
  void MergeFrom(const LinearMappingFuction1D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.LinearExpr linearTimeMap = 1;
  inline bool has_lineartimemap() const;
  inline void clear_lineartimemap();
  static const int kLinearTimeMapFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::LinearExpr& lineartimemap() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_lineartimemap();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_lineartimemap();
  inline void set_allocated_lineartimemap(::FabByExample::proto::symbolic::LinearExpr* lineartimemap);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.LinearMappingFuction1D)
 private:
  inline void set_has_lineartimemap();
  inline void clear_has_lineartimemap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::LinearExpr* lineartimemap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static LinearMappingFuction1D* default_instance_;
};
// -------------------------------------------------------------------

class PiecewiseLinearFunction1D : public ::google::protobuf::Message {
 public:
  PiecewiseLinearFunction1D();
  virtual ~PiecewiseLinearFunction1D();

  PiecewiseLinearFunction1D(const PiecewiseLinearFunction1D& from);

  inline PiecewiseLinearFunction1D& operator=(const PiecewiseLinearFunction1D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PiecewiseLinearFunction1D& default_instance();

  void Swap(PiecewiseLinearFunction1D* other);

  // implements Message ----------------------------------------------

  PiecewiseLinearFunction1D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PiecewiseLinearFunction1D& from);
  void MergeFrom(const PiecewiseLinearFunction1D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FabByExample.proto.symbolic.TimeAndValuePair timesandvalues = 1;
  inline int timesandvalues_size() const;
  inline void clear_timesandvalues();
  static const int kTimesandvaluesFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::TimeAndValuePair& timesandvalues(int index) const;
  inline ::FabByExample::proto::symbolic::TimeAndValuePair* mutable_timesandvalues(int index);
  inline ::FabByExample::proto::symbolic::TimeAndValuePair* add_timesandvalues();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::TimeAndValuePair >&
      timesandvalues() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::TimeAndValuePair >*
      mutable_timesandvalues();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.PiecewiseLinearFunction1D)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::TimeAndValuePair > timesandvalues_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static PiecewiseLinearFunction1D* default_instance_;
};
// -------------------------------------------------------------------

class TimeAndValuePair : public ::google::protobuf::Message {
 public:
  TimeAndValuePair();
  virtual ~TimeAndValuePair();

  TimeAndValuePair(const TimeAndValuePair& from);

  inline TimeAndValuePair& operator=(const TimeAndValuePair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeAndValuePair& default_instance();

  void Swap(TimeAndValuePair* other);

  // implements Message ----------------------------------------------

  TimeAndValuePair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeAndValuePair& from);
  void MergeFrom(const TimeAndValuePair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double timeStamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.TimeAndValuePair)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double timestamp_;
  double value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static TimeAndValuePair* default_instance_;
};
// -------------------------------------------------------------------

class PWLinear : public ::google::protobuf::Message {
 public:
  PWLinear();
  virtual ~PWLinear();

  PWLinear(const PWLinear& from);

  inline PWLinear& operator=(const PWLinear& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PWLinear& default_instance();

  void Swap(PWLinear* other);

  // implements Message ----------------------------------------------

  PWLinear* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PWLinear& from);
  void MergeFrom(const PWLinear& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FabByExample.proto.symbolic.LinearExpr time = 1;
  inline int time_size() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::LinearExpr& time(int index) const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_time(int index);
  inline ::FabByExample::proto::symbolic::LinearExpr* add_time();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >&
      time() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >*
      mutable_time();

  // repeated .FabByExample.proto.symbolic.LinearExpr value = 2;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::FabByExample::proto::symbolic::LinearExpr& value(int index) const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_value(int index);
  inline ::FabByExample::proto::symbolic::LinearExpr* add_value();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >&
      value() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.symbolic.PWLinear)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr > time_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_symbolic_2eproto();
  friend void protobuf_AssignDesc_symbolic_2eproto();
  friend void protobuf_ShutdownFile_symbolic_2eproto();

  void InitAsDefaultInstance();
  static PWLinear* default_instance_;
};
// ===================================================================


// ===================================================================

// Parameter

// optional int32 id = 1;
inline bool Parameter::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parameter::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parameter::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parameter::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Parameter::id() const {
  return id_;
}
inline void Parameter::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Parameter::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameter::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameter::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Parameter::name() const {
  return *name_;
}
inline void Parameter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Parameter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Parameter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Parameter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Parameter::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional double default = 3;
inline bool Parameter::has_default_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Parameter::set_has_default_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Parameter::clear_has_default_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Parameter::clear_default_() {
  default__ = 0;
  clear_has_default_();
}
inline double Parameter::default_() const {
  return default__;
}
inline void Parameter::set_default_(double value) {
  set_has_default_();
  default__ = value;
}

// -------------------------------------------------------------------

// LinearExpr

// repeated int32 parameter_id = 1;
inline int LinearExpr::parameter_id_size() const {
  return parameter_id_.size();
}
inline void LinearExpr::clear_parameter_id() {
  parameter_id_.Clear();
}
inline ::google::protobuf::int32 LinearExpr::parameter_id(int index) const {
  return parameter_id_.Get(index);
}
inline void LinearExpr::set_parameter_id(int index, ::google::protobuf::int32 value) {
  parameter_id_.Set(index, value);
}
inline void LinearExpr::add_parameter_id(::google::protobuf::int32 value) {
  parameter_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LinearExpr::parameter_id() const {
  return parameter_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LinearExpr::mutable_parameter_id() {
  return &parameter_id_;
}

// repeated double coeff = 2;
inline int LinearExpr::coeff_size() const {
  return coeff_.size();
}
inline void LinearExpr::clear_coeff() {
  coeff_.Clear();
}
inline double LinearExpr::coeff(int index) const {
  return coeff_.Get(index);
}
inline void LinearExpr::set_coeff(int index, double value) {
  coeff_.Set(index, value);
}
inline void LinearExpr::add_coeff(double value) {
  coeff_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
LinearExpr::coeff() const {
  return coeff_;
}
inline ::google::protobuf::RepeatedField< double >*
LinearExpr::mutable_coeff() {
  return &coeff_;
}

// optional double const = 3;
inline bool LinearExpr::has_const_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinearExpr::set_has_const_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinearExpr::clear_has_const_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinearExpr::clear_const_() {
  const__ = 0;
  clear_has_const_();
}
inline double LinearExpr::const_() const {
  return const__;
}
inline void LinearExpr::set_const_(double value) {
  set_has_const_();
  const__ = value;
}

// -------------------------------------------------------------------

// Point2S

// optional .FabByExample.proto.symbolic.LinearExpr x = 1;
inline bool Point2S::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2S::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point2S::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point2S::clear_x() {
  if (x_ != NULL) x_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_x();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& Point2S::x() const {
  return x_ != NULL ? *x_ : *default_instance_->x_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* Point2S::mutable_x() {
  set_has_x();
  if (x_ == NULL) x_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return x_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* Point2S::release_x() {
  clear_has_x();
  ::FabByExample::proto::symbolic::LinearExpr* temp = x_;
  x_ = NULL;
  return temp;
}
inline void Point2S::set_allocated_x(::FabByExample::proto::symbolic::LinearExpr* x) {
  delete x_;
  x_ = x;
  if (x) {
    set_has_x();
  } else {
    clear_has_x();
  }
}

// optional .FabByExample.proto.symbolic.LinearExpr y = 2;
inline bool Point2S::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2S::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point2S::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point2S::clear_y() {
  if (y_ != NULL) y_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_y();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& Point2S::y() const {
  return y_ != NULL ? *y_ : *default_instance_->y_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* Point2S::mutable_y() {
  set_has_y();
  if (y_ == NULL) y_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return y_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* Point2S::release_y() {
  clear_has_y();
  ::FabByExample::proto::symbolic::LinearExpr* temp = y_;
  y_ = NULL;
  return temp;
}
inline void Point2S::set_allocated_y(::FabByExample::proto::symbolic::LinearExpr* y) {
  delete y_;
  y_ = y;
  if (y) {
    set_has_y();
  } else {
    clear_has_y();
  }
}

// -------------------------------------------------------------------

// Point3S

// optional .FabByExample.proto.symbolic.LinearExpr x = 1;
inline bool Point3S::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point3S::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point3S::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point3S::clear_x() {
  if (x_ != NULL) x_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_x();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& Point3S::x() const {
  return x_ != NULL ? *x_ : *default_instance_->x_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* Point3S::mutable_x() {
  set_has_x();
  if (x_ == NULL) x_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return x_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* Point3S::release_x() {
  clear_has_x();
  ::FabByExample::proto::symbolic::LinearExpr* temp = x_;
  x_ = NULL;
  return temp;
}
inline void Point3S::set_allocated_x(::FabByExample::proto::symbolic::LinearExpr* x) {
  delete x_;
  x_ = x;
  if (x) {
    set_has_x();
  } else {
    clear_has_x();
  }
}

// optional .FabByExample.proto.symbolic.LinearExpr y = 2;
inline bool Point3S::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point3S::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point3S::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point3S::clear_y() {
  if (y_ != NULL) y_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_y();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& Point3S::y() const {
  return y_ != NULL ? *y_ : *default_instance_->y_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* Point3S::mutable_y() {
  set_has_y();
  if (y_ == NULL) y_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return y_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* Point3S::release_y() {
  clear_has_y();
  ::FabByExample::proto::symbolic::LinearExpr* temp = y_;
  y_ = NULL;
  return temp;
}
inline void Point3S::set_allocated_y(::FabByExample::proto::symbolic::LinearExpr* y) {
  delete y_;
  y_ = y;
  if (y) {
    set_has_y();
  } else {
    clear_has_y();
  }
}

// optional .FabByExample.proto.symbolic.LinearExpr z = 3;
inline bool Point3S::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point3S::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point3S::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point3S::clear_z() {
  if (z_ != NULL) z_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_z();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& Point3S::z() const {
  return z_ != NULL ? *z_ : *default_instance_->z_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* Point3S::mutable_z() {
  set_has_z();
  if (z_ == NULL) z_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return z_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* Point3S::release_z() {
  clear_has_z();
  ::FabByExample::proto::symbolic::LinearExpr* temp = z_;
  z_ = NULL;
  return temp;
}
inline void Point3S::set_allocated_z(::FabByExample::proto::symbolic::LinearExpr* z) {
  delete z_;
  z_ = z;
  if (z) {
    set_has_z();
  } else {
    clear_has_z();
  }
}

// -------------------------------------------------------------------

// Vertex2S

// optional int32 id = 1;
inline bool Vertex2S::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vertex2S::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vertex2S::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vertex2S::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Vertex2S::id() const {
  return id_;
}
inline void Vertex2S::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Vertex2S::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vertex2S::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vertex2S::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vertex2S::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Vertex2S::name() const {
  return *name_;
}
inline void Vertex2S::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Vertex2S::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Vertex2S::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Vertex2S::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Vertex2S::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Vertex2S::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .FabByExample.proto.symbolic.Point2S point = 3;
inline bool Vertex2S::has_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vertex2S::set_has_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vertex2S::clear_has_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vertex2S::clear_point() {
  if (point_ != NULL) point_->::FabByExample::proto::symbolic::Point2S::Clear();
  clear_has_point();
}
inline const ::FabByExample::proto::symbolic::Point2S& Vertex2S::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::FabByExample::proto::symbolic::Point2S* Vertex2S::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::FabByExample::proto::symbolic::Point2S;
  return point_;
}
inline ::FabByExample::proto::symbolic::Point2S* Vertex2S::release_point() {
  clear_has_point();
  ::FabByExample::proto::symbolic::Point2S* temp = point_;
  point_ = NULL;
  return temp;
}
inline void Vertex2S::set_allocated_point(::FabByExample::proto::symbolic::Point2S* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// -------------------------------------------------------------------

// Edge2S

// optional int32 id = 1;
inline bool Edge2S::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge2S::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge2S::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge2S::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Edge2S::id() const {
  return id_;
}
inline void Edge2S::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Edge2S::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge2S::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge2S::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge2S::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Edge2S::name() const {
  return *name_;
}
inline void Edge2S::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Edge2S::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Edge2S::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Edge2S::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Edge2S::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Edge2S::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int32 vertex1_id = 3;
inline bool Edge2S::has_vertex1_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Edge2S::set_has_vertex1_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Edge2S::clear_has_vertex1_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Edge2S::clear_vertex1_id() {
  vertex1_id_ = 0;
  clear_has_vertex1_id();
}
inline ::google::protobuf::int32 Edge2S::vertex1_id() const {
  return vertex1_id_;
}
inline void Edge2S::set_vertex1_id(::google::protobuf::int32 value) {
  set_has_vertex1_id();
  vertex1_id_ = value;
}

// optional int32 vertex2_id = 4;
inline bool Edge2S::has_vertex2_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Edge2S::set_has_vertex2_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Edge2S::clear_has_vertex2_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Edge2S::clear_vertex2_id() {
  vertex2_id_ = 0;
  clear_has_vertex2_id();
}
inline ::google::protobuf::int32 Edge2S::vertex2_id() const {
  return vertex2_id_;
}
inline void Edge2S::set_vertex2_id(::google::protobuf::int32 value) {
  set_has_vertex2_id();
  vertex2_id_ = value;
}

// -------------------------------------------------------------------

// Face2S

// optional int32 id = 1;
inline bool Face2S::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Face2S::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Face2S::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Face2S::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Face2S::id() const {
  return id_;
}
inline void Face2S::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Face2S::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Face2S::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Face2S::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Face2S::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Face2S::name() const {
  return *name_;
}
inline void Face2S::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Face2S::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Face2S::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Face2S::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Face2S::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Face2S::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated int32 vertex_id = 3;
inline int Face2S::vertex_id_size() const {
  return vertex_id_.size();
}
inline void Face2S::clear_vertex_id() {
  vertex_id_.Clear();
}
inline ::google::protobuf::int32 Face2S::vertex_id(int index) const {
  return vertex_id_.Get(index);
}
inline void Face2S::set_vertex_id(int index, ::google::protobuf::int32 value) {
  vertex_id_.Set(index, value);
}
inline void Face2S::add_vertex_id(::google::protobuf::int32 value) {
  vertex_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Face2S::vertex_id() const {
  return vertex_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Face2S::mutable_vertex_id() {
  return &vertex_id_;
}

// repeated int32 edge_id = 4;
inline int Face2S::edge_id_size() const {
  return edge_id_.size();
}
inline void Face2S::clear_edge_id() {
  edge_id_.Clear();
}
inline ::google::protobuf::int32 Face2S::edge_id(int index) const {
  return edge_id_.Get(index);
}
inline void Face2S::set_edge_id(int index, ::google::protobuf::int32 value) {
  edge_id_.Set(index, value);
}
inline void Face2S::add_edge_id(::google::protobuf::int32 value) {
  edge_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Face2S::edge_id() const {
  return edge_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Face2S::mutable_edge_id() {
  return &edge_id_;
}

// -------------------------------------------------------------------

// Drawing2S

// optional int32 id = 1;
inline bool Drawing2S::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Drawing2S::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Drawing2S::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Drawing2S::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Drawing2S::id() const {
  return id_;
}
inline void Drawing2S::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Drawing2S::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Drawing2S::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Drawing2S::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Drawing2S::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Drawing2S::name() const {
  return *name_;
}
inline void Drawing2S::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Drawing2S::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Drawing2S::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Drawing2S::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Drawing2S::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Drawing2S::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .FabByExample.proto.symbolic.Vertex2S vertex = 3;
inline int Drawing2S::vertex_size() const {
  return vertex_.size();
}
inline void Drawing2S::clear_vertex() {
  vertex_.Clear();
}
inline const ::FabByExample::proto::symbolic::Vertex2S& Drawing2S::vertex(int index) const {
  return vertex_.Get(index);
}
inline ::FabByExample::proto::symbolic::Vertex2S* Drawing2S::mutable_vertex(int index) {
  return vertex_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::Vertex2S* Drawing2S::add_vertex() {
  return vertex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Vertex2S >&
Drawing2S::vertex() const {
  return vertex_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Vertex2S >*
Drawing2S::mutable_vertex() {
  return &vertex_;
}

// repeated .FabByExample.proto.symbolic.Edge2S edge = 4;
inline int Drawing2S::edge_size() const {
  return edge_.size();
}
inline void Drawing2S::clear_edge() {
  edge_.Clear();
}
inline const ::FabByExample::proto::symbolic::Edge2S& Drawing2S::edge(int index) const {
  return edge_.Get(index);
}
inline ::FabByExample::proto::symbolic::Edge2S* Drawing2S::mutable_edge(int index) {
  return edge_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::Edge2S* Drawing2S::add_edge() {
  return edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Edge2S >&
Drawing2S::edge() const {
  return edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Edge2S >*
Drawing2S::mutable_edge() {
  return &edge_;
}

// repeated .FabByExample.proto.symbolic.Face2S face = 5;
inline int Drawing2S::face_size() const {
  return face_.size();
}
inline void Drawing2S::clear_face() {
  face_.Clear();
}
inline const ::FabByExample::proto::symbolic::Face2S& Drawing2S::face(int index) const {
  return face_.Get(index);
}
inline ::FabByExample::proto::symbolic::Face2S* Drawing2S::mutable_face(int index) {
  return face_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::Face2S* Drawing2S::add_face() {
  return face_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Face2S >&
Drawing2S::face() const {
  return face_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Face2S >*
Drawing2S::mutable_face() {
  return &face_;
}

// -------------------------------------------------------------------

// Vertex3S

// optional int32 id = 1;
inline bool Vertex3S::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vertex3S::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vertex3S::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vertex3S::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Vertex3S::id() const {
  return id_;
}
inline void Vertex3S::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Vertex3S::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vertex3S::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vertex3S::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vertex3S::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Vertex3S::name() const {
  return *name_;
}
inline void Vertex3S::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Vertex3S::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Vertex3S::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Vertex3S::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Vertex3S::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Vertex3S::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .FabByExample.proto.symbolic.Point3S point = 3;
inline bool Vertex3S::has_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vertex3S::set_has_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vertex3S::clear_has_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vertex3S::clear_point() {
  if (point_ != NULL) point_->::FabByExample::proto::symbolic::Point3S::Clear();
  clear_has_point();
}
inline const ::FabByExample::proto::symbolic::Point3S& Vertex3S::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::FabByExample::proto::symbolic::Point3S* Vertex3S::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::FabByExample::proto::symbolic::Point3S;
  return point_;
}
inline ::FabByExample::proto::symbolic::Point3S* Vertex3S::release_point() {
  clear_has_point();
  ::FabByExample::proto::symbolic::Point3S* temp = point_;
  point_ = NULL;
  return temp;
}
inline void Vertex3S::set_allocated_point(::FabByExample::proto::symbolic::Point3S* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// -------------------------------------------------------------------

// Edge3S

// optional int32 id = 1;
inline bool Edge3S::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge3S::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge3S::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge3S::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Edge3S::id() const {
  return id_;
}
inline void Edge3S::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Edge3S::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge3S::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge3S::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge3S::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Edge3S::name() const {
  return *name_;
}
inline void Edge3S::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Edge3S::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Edge3S::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Edge3S::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Edge3S::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Edge3S::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int32 vertex1_id = 3;
inline bool Edge3S::has_vertex1_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Edge3S::set_has_vertex1_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Edge3S::clear_has_vertex1_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Edge3S::clear_vertex1_id() {
  vertex1_id_ = 0;
  clear_has_vertex1_id();
}
inline ::google::protobuf::int32 Edge3S::vertex1_id() const {
  return vertex1_id_;
}
inline void Edge3S::set_vertex1_id(::google::protobuf::int32 value) {
  set_has_vertex1_id();
  vertex1_id_ = value;
}

// optional int32 vertex2_id = 4;
inline bool Edge3S::has_vertex2_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Edge3S::set_has_vertex2_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Edge3S::clear_has_vertex2_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Edge3S::clear_vertex2_id() {
  vertex2_id_ = 0;
  clear_has_vertex2_id();
}
inline ::google::protobuf::int32 Edge3S::vertex2_id() const {
  return vertex2_id_;
}
inline void Edge3S::set_vertex2_id(::google::protobuf::int32 value) {
  set_has_vertex2_id();
  vertex2_id_ = value;
}

// -------------------------------------------------------------------

// Face3S

// optional int32 id = 1;
inline bool Face3S::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Face3S::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Face3S::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Face3S::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Face3S::id() const {
  return id_;
}
inline void Face3S::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Face3S::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Face3S::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Face3S::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Face3S::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Face3S::name() const {
  return *name_;
}
inline void Face3S::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Face3S::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Face3S::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Face3S::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Face3S::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Face3S::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated int32 vertex_id = 3;
inline int Face3S::vertex_id_size() const {
  return vertex_id_.size();
}
inline void Face3S::clear_vertex_id() {
  vertex_id_.Clear();
}
inline ::google::protobuf::int32 Face3S::vertex_id(int index) const {
  return vertex_id_.Get(index);
}
inline void Face3S::set_vertex_id(int index, ::google::protobuf::int32 value) {
  vertex_id_.Set(index, value);
}
inline void Face3S::add_vertex_id(::google::protobuf::int32 value) {
  vertex_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Face3S::vertex_id() const {
  return vertex_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Face3S::mutable_vertex_id() {
  return &vertex_id_;
}

// repeated int32 edge_id = 4;
inline int Face3S::edge_id_size() const {
  return edge_id_.size();
}
inline void Face3S::clear_edge_id() {
  edge_id_.Clear();
}
inline ::google::protobuf::int32 Face3S::edge_id(int index) const {
  return edge_id_.Get(index);
}
inline void Face3S::set_edge_id(int index, ::google::protobuf::int32 value) {
  edge_id_.Set(index, value);
}
inline void Face3S::add_edge_id(::google::protobuf::int32 value) {
  edge_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Face3S::edge_id() const {
  return edge_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Face3S::mutable_edge_id() {
  return &edge_id_;
}

// -------------------------------------------------------------------

// Mesh3S

// optional int32 id = 1;
inline bool Mesh3S::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mesh3S::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mesh3S::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mesh3S::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Mesh3S::id() const {
  return id_;
}
inline void Mesh3S::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 name = 2;
inline bool Mesh3S::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mesh3S::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mesh3S::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mesh3S::clear_name() {
  name_ = 0;
  clear_has_name();
}
inline ::google::protobuf::int32 Mesh3S::name() const {
  return name_;
}
inline void Mesh3S::set_name(::google::protobuf::int32 value) {
  set_has_name();
  name_ = value;
}

// repeated .FabByExample.proto.symbolic.Vertex3S vertex = 3;
inline int Mesh3S::vertex_size() const {
  return vertex_.size();
}
inline void Mesh3S::clear_vertex() {
  vertex_.Clear();
}
inline const ::FabByExample::proto::symbolic::Vertex3S& Mesh3S::vertex(int index) const {
  return vertex_.Get(index);
}
inline ::FabByExample::proto::symbolic::Vertex3S* Mesh3S::mutable_vertex(int index) {
  return vertex_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::Vertex3S* Mesh3S::add_vertex() {
  return vertex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Vertex3S >&
Mesh3S::vertex() const {
  return vertex_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Vertex3S >*
Mesh3S::mutable_vertex() {
  return &vertex_;
}

// repeated .FabByExample.proto.symbolic.Edge3S edge = 4;
inline int Mesh3S::edge_size() const {
  return edge_.size();
}
inline void Mesh3S::clear_edge() {
  edge_.Clear();
}
inline const ::FabByExample::proto::symbolic::Edge3S& Mesh3S::edge(int index) const {
  return edge_.Get(index);
}
inline ::FabByExample::proto::symbolic::Edge3S* Mesh3S::mutable_edge(int index) {
  return edge_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::Edge3S* Mesh3S::add_edge() {
  return edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Edge3S >&
Mesh3S::edge() const {
  return edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Edge3S >*
Mesh3S::mutable_edge() {
  return &edge_;
}

// repeated .FabByExample.proto.symbolic.Face3S face = 5;
inline int Mesh3S::face_size() const {
  return face_.size();
}
inline void Mesh3S::clear_face() {
  face_.Clear();
}
inline const ::FabByExample::proto::symbolic::Face3S& Mesh3S::face(int index) const {
  return face_.Get(index);
}
inline ::FabByExample::proto::symbolic::Face3S* Mesh3S::mutable_face(int index) {
  return face_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::Face3S* Mesh3S::add_face() {
  return face_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Face3S >&
Mesh3S::face() const {
  return face_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Face3S >*
Mesh3S::mutable_face() {
  return &face_;
}

// -------------------------------------------------------------------

// AffineMatrix3S

// repeated .FabByExample.proto.symbolic.LinearExpr value = 1;
inline int AffineMatrix3S::value_size() const {
  return value_.size();
}
inline void AffineMatrix3S::clear_value() {
  value_.Clear();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& AffineMatrix3S::value(int index) const {
  return value_.Get(index);
}
inline ::FabByExample::proto::symbolic::LinearExpr* AffineMatrix3S::mutable_value(int index) {
  return value_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::LinearExpr* AffineMatrix3S::add_value() {
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >&
AffineMatrix3S::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >*
AffineMatrix3S::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// Transform

// optional .FabByExample.proto.symbolic.Control control = 1;
inline bool Transform::has_control() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transform::set_has_control() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transform::clear_has_control() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transform::clear_control() {
  if (control_ != NULL) control_->::FabByExample::proto::symbolic::Control::Clear();
  clear_has_control();
}
inline const ::FabByExample::proto::symbolic::Control& Transform::control() const {
  return control_ != NULL ? *control_ : *default_instance_->control_;
}
inline ::FabByExample::proto::symbolic::Control* Transform::mutable_control() {
  set_has_control();
  if (control_ == NULL) control_ = new ::FabByExample::proto::symbolic::Control;
  return control_;
}
inline ::FabByExample::proto::symbolic::Control* Transform::release_control() {
  clear_has_control();
  ::FabByExample::proto::symbolic::Control* temp = control_;
  control_ = NULL;
  return temp;
}
inline void Transform::set_allocated_control(::FabByExample::proto::symbolic::Control* control) {
  delete control_;
  control_ = control;
  if (control) {
    set_has_control();
  } else {
    clear_has_control();
  }
}

// optional .FabByExample.proto.symbolic.Point3S axis = 2;
inline bool Transform::has_axis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transform::set_has_axis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transform::clear_has_axis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transform::clear_axis() {
  if (axis_ != NULL) axis_->::FabByExample::proto::symbolic::Point3S::Clear();
  clear_has_axis();
}
inline const ::FabByExample::proto::symbolic::Point3S& Transform::axis() const {
  return axis_ != NULL ? *axis_ : *default_instance_->axis_;
}
inline ::FabByExample::proto::symbolic::Point3S* Transform::mutable_axis() {
  set_has_axis();
  if (axis_ == NULL) axis_ = new ::FabByExample::proto::symbolic::Point3S;
  return axis_;
}
inline ::FabByExample::proto::symbolic::Point3S* Transform::release_axis() {
  clear_has_axis();
  ::FabByExample::proto::symbolic::Point3S* temp = axis_;
  axis_ = NULL;
  return temp;
}
inline void Transform::set_allocated_axis(::FabByExample::proto::symbolic::Point3S* axis) {
  delete axis_;
  axis_ = axis;
  if (axis) {
    set_has_axis();
  } else {
    clear_has_axis();
  }
}

// optional .FabByExample.proto.symbolic.Transform.TransformType type = 3;
inline bool Transform::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transform::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transform::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transform::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::FabByExample::proto::symbolic::Transform_TransformType Transform::type() const {
  return static_cast< ::FabByExample::proto::symbolic::Transform_TransformType >(type_);
}
inline void Transform::set_type(::FabByExample::proto::symbolic::Transform_TransformType value) {
  assert(::FabByExample::proto::symbolic::Transform_TransformType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double minVal = 4;
inline bool Transform::has_minval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Transform::set_has_minval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Transform::clear_has_minval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Transform::clear_minval() {
  minval_ = 0;
  clear_has_minval();
}
inline double Transform::minval() const {
  return minval_;
}
inline void Transform::set_minval(double value) {
  set_has_minval();
  minval_ = value;
}

// optional double maxVal = 5;
inline bool Transform::has_maxval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Transform::set_has_maxval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Transform::clear_has_maxval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Transform::clear_maxval() {
  maxval_ = 0;
  clear_has_maxval();
}
inline double Transform::maxval() const {
  return maxval_;
}
inline void Transform::set_maxval(double value) {
  set_has_maxval();
  maxval_ = value;
}

// -------------------------------------------------------------------

// Control

// optional int32 id = 1;
inline bool Control::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Control::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Control::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Control::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Control::id() const {
  return id_;
}
inline void Control::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Control::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Control::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Control::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Control::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Control::name() const {
  return *name_;
}
inline void Control::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Control::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Control::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Control::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Control::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Control::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .FabByExample.proto.symbolic.ControlMappingFunction inputs = 3;
inline bool Control::has_inputs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Control::set_has_inputs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Control::clear_has_inputs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Control::clear_inputs() {
  if (inputs_ != NULL) inputs_->::FabByExample::proto::symbolic::ControlMappingFunction::Clear();
  clear_has_inputs();
}
inline const ::FabByExample::proto::symbolic::ControlMappingFunction& Control::inputs() const {
  return inputs_ != NULL ? *inputs_ : *default_instance_->inputs_;
}
inline ::FabByExample::proto::symbolic::ControlMappingFunction* Control::mutable_inputs() {
  set_has_inputs();
  if (inputs_ == NULL) inputs_ = new ::FabByExample::proto::symbolic::ControlMappingFunction;
  return inputs_;
}
inline ::FabByExample::proto::symbolic::ControlMappingFunction* Control::release_inputs() {
  clear_has_inputs();
  ::FabByExample::proto::symbolic::ControlMappingFunction* temp = inputs_;
  inputs_ = NULL;
  return temp;
}
inline void Control::set_allocated_inputs(::FabByExample::proto::symbolic::ControlMappingFunction* inputs) {
  delete inputs_;
  inputs_ = inputs;
  if (inputs) {
    set_has_inputs();
  } else {
    clear_has_inputs();
  }
}

// -------------------------------------------------------------------

// ControlMappingFunction

// optional .FabByExample.proto.symbolic.LinearMappingFuction1D linear_1 = 1;
inline bool ControlMappingFunction::has_linear_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlMappingFunction::set_has_linear_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlMappingFunction::clear_has_linear_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlMappingFunction::clear_linear_1() {
  if (linear_1_ != NULL) linear_1_->::FabByExample::proto::symbolic::LinearMappingFuction1D::Clear();
  clear_has_linear_1();
}
inline const ::FabByExample::proto::symbolic::LinearMappingFuction1D& ControlMappingFunction::linear_1() const {
  return linear_1_ != NULL ? *linear_1_ : *default_instance_->linear_1_;
}
inline ::FabByExample::proto::symbolic::LinearMappingFuction1D* ControlMappingFunction::mutable_linear_1() {
  set_has_linear_1();
  if (linear_1_ == NULL) linear_1_ = new ::FabByExample::proto::symbolic::LinearMappingFuction1D;
  return linear_1_;
}
inline ::FabByExample::proto::symbolic::LinearMappingFuction1D* ControlMappingFunction::release_linear_1() {
  clear_has_linear_1();
  ::FabByExample::proto::symbolic::LinearMappingFuction1D* temp = linear_1_;
  linear_1_ = NULL;
  return temp;
}
inline void ControlMappingFunction::set_allocated_linear_1(::FabByExample::proto::symbolic::LinearMappingFuction1D* linear_1) {
  delete linear_1_;
  linear_1_ = linear_1;
  if (linear_1) {
    set_has_linear_1();
  } else {
    clear_has_linear_1();
  }
}

// optional .FabByExample.proto.symbolic.PiecewiseLinearFunction1D piecewiselinear = 2;
inline bool ControlMappingFunction::has_piecewiselinear() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlMappingFunction::set_has_piecewiselinear() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlMappingFunction::clear_has_piecewiselinear() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlMappingFunction::clear_piecewiselinear() {
  if (piecewiselinear_ != NULL) piecewiselinear_->::FabByExample::proto::symbolic::PiecewiseLinearFunction1D::Clear();
  clear_has_piecewiselinear();
}
inline const ::FabByExample::proto::symbolic::PiecewiseLinearFunction1D& ControlMappingFunction::piecewiselinear() const {
  return piecewiselinear_ != NULL ? *piecewiselinear_ : *default_instance_->piecewiselinear_;
}
inline ::FabByExample::proto::symbolic::PiecewiseLinearFunction1D* ControlMappingFunction::mutable_piecewiselinear() {
  set_has_piecewiselinear();
  if (piecewiselinear_ == NULL) piecewiselinear_ = new ::FabByExample::proto::symbolic::PiecewiseLinearFunction1D;
  return piecewiselinear_;
}
inline ::FabByExample::proto::symbolic::PiecewiseLinearFunction1D* ControlMappingFunction::release_piecewiselinear() {
  clear_has_piecewiselinear();
  ::FabByExample::proto::symbolic::PiecewiseLinearFunction1D* temp = piecewiselinear_;
  piecewiselinear_ = NULL;
  return temp;
}
inline void ControlMappingFunction::set_allocated_piecewiselinear(::FabByExample::proto::symbolic::PiecewiseLinearFunction1D* piecewiselinear) {
  delete piecewiselinear_;
  piecewiselinear_ = piecewiselinear;
  if (piecewiselinear) {
    set_has_piecewiselinear();
  } else {
    clear_has_piecewiselinear();
  }
}

// optional .FabByExample.proto.symbolic.ParametricPiecewiseLinearFunction piecewiseFunction = 3;
inline bool ControlMappingFunction::has_piecewisefunction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControlMappingFunction::set_has_piecewisefunction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControlMappingFunction::clear_has_piecewisefunction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControlMappingFunction::clear_piecewisefunction() {
  if (piecewisefunction_ != NULL) piecewisefunction_->::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction::Clear();
  clear_has_piecewisefunction();
}
inline const ::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction& ControlMappingFunction::piecewisefunction() const {
  return piecewisefunction_ != NULL ? *piecewisefunction_ : *default_instance_->piecewisefunction_;
}
inline ::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction* ControlMappingFunction::mutable_piecewisefunction() {
  set_has_piecewisefunction();
  if (piecewisefunction_ == NULL) piecewisefunction_ = new ::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction;
  return piecewisefunction_;
}
inline ::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction* ControlMappingFunction::release_piecewisefunction() {
  clear_has_piecewisefunction();
  ::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction* temp = piecewisefunction_;
  piecewisefunction_ = NULL;
  return temp;
}
inline void ControlMappingFunction::set_allocated_piecewisefunction(::FabByExample::proto::symbolic::ParametricPiecewiseLinearFunction* piecewisefunction) {
  delete piecewisefunction_;
  piecewisefunction_ = piecewisefunction;
  if (piecewisefunction) {
    set_has_piecewisefunction();
  } else {
    clear_has_piecewisefunction();
  }
}

// optional int32 symbolicController = 4;
inline bool ControlMappingFunction::has_symboliccontroller() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControlMappingFunction::set_has_symboliccontroller() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControlMappingFunction::clear_has_symboliccontroller() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControlMappingFunction::clear_symboliccontroller() {
  symboliccontroller_ = 0;
  clear_has_symboliccontroller();
}
inline ::google::protobuf::int32 ControlMappingFunction::symboliccontroller() const {
  return symboliccontroller_;
}
inline void ControlMappingFunction::set_symboliccontroller(::google::protobuf::int32 value) {
  set_has_symboliccontroller();
  symboliccontroller_ = value;
}

// optional .FabByExample.proto.symbolic.GrammarControllerMappingFunction grammarFunction = 5;
inline bool ControlMappingFunction::has_grammarfunction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ControlMappingFunction::set_has_grammarfunction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ControlMappingFunction::clear_has_grammarfunction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ControlMappingFunction::clear_grammarfunction() {
  if (grammarfunction_ != NULL) grammarfunction_->::FabByExample::proto::symbolic::GrammarControllerMappingFunction::Clear();
  clear_has_grammarfunction();
}
inline const ::FabByExample::proto::symbolic::GrammarControllerMappingFunction& ControlMappingFunction::grammarfunction() const {
  return grammarfunction_ != NULL ? *grammarfunction_ : *default_instance_->grammarfunction_;
}
inline ::FabByExample::proto::symbolic::GrammarControllerMappingFunction* ControlMappingFunction::mutable_grammarfunction() {
  set_has_grammarfunction();
  if (grammarfunction_ == NULL) grammarfunction_ = new ::FabByExample::proto::symbolic::GrammarControllerMappingFunction;
  return grammarfunction_;
}
inline ::FabByExample::proto::symbolic::GrammarControllerMappingFunction* ControlMappingFunction::release_grammarfunction() {
  clear_has_grammarfunction();
  ::FabByExample::proto::symbolic::GrammarControllerMappingFunction* temp = grammarfunction_;
  grammarfunction_ = NULL;
  return temp;
}
inline void ControlMappingFunction::set_allocated_grammarfunction(::FabByExample::proto::symbolic::GrammarControllerMappingFunction* grammarfunction) {
  delete grammarfunction_;
  grammarfunction_ = grammarfunction;
  if (grammarfunction) {
    set_has_grammarfunction();
  } else {
    clear_has_grammarfunction();
  }
}

// -------------------------------------------------------------------

// ParametricPiecewiseLinearFunction

// repeated .FabByExample.proto.symbolic.PWLinear pairs = 1;
inline int ParametricPiecewiseLinearFunction::pairs_size() const {
  return pairs_.size();
}
inline void ParametricPiecewiseLinearFunction::clear_pairs() {
  pairs_.Clear();
}
inline const ::FabByExample::proto::symbolic::PWLinear& ParametricPiecewiseLinearFunction::pairs(int index) const {
  return pairs_.Get(index);
}
inline ::FabByExample::proto::symbolic::PWLinear* ParametricPiecewiseLinearFunction::mutable_pairs(int index) {
  return pairs_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::PWLinear* ParametricPiecewiseLinearFunction::add_pairs() {
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::PWLinear >&
ParametricPiecewiseLinearFunction::pairs() const {
  return pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::PWLinear >*
ParametricPiecewiseLinearFunction::mutable_pairs() {
  return &pairs_;
}

// -------------------------------------------------------------------

// GrammarControllerMappingFunction

// optional .FabByExample.proto.symbolic.GrammarControllerMappingFunction.GrammarControllerType type = 1;
inline bool GrammarControllerMappingFunction::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GrammarControllerMappingFunction::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GrammarControllerMappingFunction::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GrammarControllerMappingFunction::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::FabByExample::proto::symbolic::GrammarControllerMappingFunction_GrammarControllerType GrammarControllerMappingFunction::type() const {
  return static_cast< ::FabByExample::proto::symbolic::GrammarControllerMappingFunction_GrammarControllerType >(type_);
}
inline void GrammarControllerMappingFunction::set_type(::FabByExample::proto::symbolic::GrammarControllerMappingFunction_GrammarControllerType value) {
  assert(::FabByExample::proto::symbolic::GrammarControllerMappingFunction_GrammarControllerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double theta = 2;
inline bool GrammarControllerMappingFunction::has_theta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GrammarControllerMappingFunction::set_has_theta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GrammarControllerMappingFunction::clear_has_theta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GrammarControllerMappingFunction::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double GrammarControllerMappingFunction::theta() const {
  return theta_;
}
inline void GrammarControllerMappingFunction::set_theta(double value) {
  set_has_theta();
  theta_ = value;
}

// optional int32 N_intervals = 3;
inline bool GrammarControllerMappingFunction::has_n_intervals() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GrammarControllerMappingFunction::set_has_n_intervals() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GrammarControllerMappingFunction::clear_has_n_intervals() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GrammarControllerMappingFunction::clear_n_intervals() {
  n_intervals_ = 0;
  clear_has_n_intervals();
}
inline ::google::protobuf::int32 GrammarControllerMappingFunction::n_intervals() const {
  return n_intervals_;
}
inline void GrammarControllerMappingFunction::set_n_intervals(::google::protobuf::int32 value) {
  set_has_n_intervals();
  n_intervals_ = value;
}

// optional int32 i_interval = 4;
inline bool GrammarControllerMappingFunction::has_i_interval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GrammarControllerMappingFunction::set_has_i_interval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GrammarControllerMappingFunction::clear_has_i_interval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GrammarControllerMappingFunction::clear_i_interval() {
  i_interval_ = 0;
  clear_has_i_interval();
}
inline ::google::protobuf::int32 GrammarControllerMappingFunction::i_interval() const {
  return i_interval_;
}
inline void GrammarControllerMappingFunction::set_i_interval(::google::protobuf::int32 value) {
  set_has_i_interval();
  i_interval_ = value;
}

// optional double multi = 5;
inline bool GrammarControllerMappingFunction::has_multi() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GrammarControllerMappingFunction::set_has_multi() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GrammarControllerMappingFunction::clear_has_multi() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GrammarControllerMappingFunction::clear_multi() {
  multi_ = 0;
  clear_has_multi();
}
inline double GrammarControllerMappingFunction::multi() const {
  return multi_;
}
inline void GrammarControllerMappingFunction::set_multi(double value) {
  set_has_multi();
  multi_ = value;
}

// -------------------------------------------------------------------

// LinearMappingFuction1D

// optional .FabByExample.proto.symbolic.LinearExpr linearTimeMap = 1;
inline bool LinearMappingFuction1D::has_lineartimemap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinearMappingFuction1D::set_has_lineartimemap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinearMappingFuction1D::clear_has_lineartimemap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinearMappingFuction1D::clear_lineartimemap() {
  if (lineartimemap_ != NULL) lineartimemap_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_lineartimemap();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& LinearMappingFuction1D::lineartimemap() const {
  return lineartimemap_ != NULL ? *lineartimemap_ : *default_instance_->lineartimemap_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* LinearMappingFuction1D::mutable_lineartimemap() {
  set_has_lineartimemap();
  if (lineartimemap_ == NULL) lineartimemap_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return lineartimemap_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* LinearMappingFuction1D::release_lineartimemap() {
  clear_has_lineartimemap();
  ::FabByExample::proto::symbolic::LinearExpr* temp = lineartimemap_;
  lineartimemap_ = NULL;
  return temp;
}
inline void LinearMappingFuction1D::set_allocated_lineartimemap(::FabByExample::proto::symbolic::LinearExpr* lineartimemap) {
  delete lineartimemap_;
  lineartimemap_ = lineartimemap;
  if (lineartimemap) {
    set_has_lineartimemap();
  } else {
    clear_has_lineartimemap();
  }
}

// -------------------------------------------------------------------

// PiecewiseLinearFunction1D

// repeated .FabByExample.proto.symbolic.TimeAndValuePair timesandvalues = 1;
inline int PiecewiseLinearFunction1D::timesandvalues_size() const {
  return timesandvalues_.size();
}
inline void PiecewiseLinearFunction1D::clear_timesandvalues() {
  timesandvalues_.Clear();
}
inline const ::FabByExample::proto::symbolic::TimeAndValuePair& PiecewiseLinearFunction1D::timesandvalues(int index) const {
  return timesandvalues_.Get(index);
}
inline ::FabByExample::proto::symbolic::TimeAndValuePair* PiecewiseLinearFunction1D::mutable_timesandvalues(int index) {
  return timesandvalues_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::TimeAndValuePair* PiecewiseLinearFunction1D::add_timesandvalues() {
  return timesandvalues_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::TimeAndValuePair >&
PiecewiseLinearFunction1D::timesandvalues() const {
  return timesandvalues_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::TimeAndValuePair >*
PiecewiseLinearFunction1D::mutable_timesandvalues() {
  return &timesandvalues_;
}

// -------------------------------------------------------------------

// TimeAndValuePair

// optional double timeStamp = 1;
inline bool TimeAndValuePair::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeAndValuePair::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeAndValuePair::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeAndValuePair::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double TimeAndValuePair::timestamp() const {
  return timestamp_;
}
inline void TimeAndValuePair::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional double value = 2;
inline bool TimeAndValuePair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeAndValuePair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeAndValuePair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeAndValuePair::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double TimeAndValuePair::value() const {
  return value_;
}
inline void TimeAndValuePair::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// PWLinear

// repeated .FabByExample.proto.symbolic.LinearExpr time = 1;
inline int PWLinear::time_size() const {
  return time_.size();
}
inline void PWLinear::clear_time() {
  time_.Clear();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& PWLinear::time(int index) const {
  return time_.Get(index);
}
inline ::FabByExample::proto::symbolic::LinearExpr* PWLinear::mutable_time(int index) {
  return time_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::LinearExpr* PWLinear::add_time() {
  return time_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >&
PWLinear::time() const {
  return time_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >*
PWLinear::mutable_time() {
  return &time_;
}

// repeated .FabByExample.proto.symbolic.LinearExpr value = 2;
inline int PWLinear::value_size() const {
  return value_.size();
}
inline void PWLinear::clear_value() {
  value_.Clear();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& PWLinear::value(int index) const {
  return value_.Get(index);
}
inline ::FabByExample::proto::symbolic::LinearExpr* PWLinear::mutable_value(int index) {
  return value_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::LinearExpr* PWLinear::add_value() {
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >&
PWLinear::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >*
PWLinear::mutable_value() {
  return &value_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace symbolic
}  // namespace proto
}  // namespace FabByExample

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FabByExample::proto::symbolic::Transform_TransformType>() {
  return ::FabByExample::proto::symbolic::Transform_TransformType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FabByExample::proto::symbolic::GrammarControllerMappingFunction_GrammarControllerType>() {
  return ::FabByExample::proto::symbolic::GrammarControllerMappingFunction_GrammarControllerType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_symbolic_2eproto__INCLUDED
