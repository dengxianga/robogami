// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: template.proto

#ifndef PROTOBUF_template_2eproto__INCLUDED
#define PROTOBUF_template_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "symbolic.pb.h"
#include "openscad.pb.h"
// @@protoc_insertion_point(includes)

namespace FabByExample {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_template_2eproto();
void protobuf_AssignDesc_template_2eproto();
void protobuf_ShutdownFile_template_2eproto();

class TemplateSet;
class GaitInformation;
class SavedGait;
class Template;
class ContactInfo;
class SymmetryChoices;
class Semantics;
class Patch;
class ServoPointPatch;
class ServoSpacingInfo;
class ServoLinePatch;
class PeripheralPatch;
class Edge2SPatch;
class Connection;
class ConnectionMode;
class FoldConnection;
class JointConnection;
class PrintType;
class BendConnection;
class FillConnection;
class FlexConnection;
class MappingFunction;
class SymbolicWayPointsMappingFunction;
class SymbolicWayPoint;
class ScadMappingFunction;
class ExternalMeshAffineMappingFunction;
class CompositionMappingFunction;
class LinearMappingFunction3;
class LinearMappingFunction2;
class FeasibleSet;
class ConstraintList;
class Constraint;
class LinearConstraint;
class Articulation;

enum Semantics_PrintMethod {
  Semantics_PrintMethod_PRINT_AND_FOLD = 1,
  Semantics_PrintMethod_DIRECT_3D = 2
};
bool Semantics_PrintMethod_IsValid(int value);
const Semantics_PrintMethod Semantics_PrintMethod_PrintMethod_MIN = Semantics_PrintMethod_PRINT_AND_FOLD;
const Semantics_PrintMethod Semantics_PrintMethod_PrintMethod_MAX = Semantics_PrintMethod_DIRECT_3D;
const int Semantics_PrintMethod_PrintMethod_ARRAYSIZE = Semantics_PrintMethod_PrintMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Semantics_PrintMethod_descriptor();
inline const ::std::string& Semantics_PrintMethod_Name(Semantics_PrintMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Semantics_PrintMethod_descriptor(), value);
}
inline bool Semantics_PrintMethod_Parse(
    const ::std::string& name, Semantics_PrintMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Semantics_PrintMethod>(
    Semantics_PrintMethod_descriptor(), name, value);
}
enum Semantics_PartType {
  Semantics_PartType_LEG = 1,
  Semantics_PartType_BODY = 2,
  Semantics_PartType_PERIPHERAL = 3,
  Semantics_PartType_FACE = 4,
  Semantics_PartType_GENERAL = 5,
  Semantics_PartType_WHEEL = 6
};
bool Semantics_PartType_IsValid(int value);
const Semantics_PartType Semantics_PartType_PartType_MIN = Semantics_PartType_LEG;
const Semantics_PartType Semantics_PartType_PartType_MAX = Semantics_PartType_WHEEL;
const int Semantics_PartType_PartType_ARRAYSIZE = Semantics_PartType_PartType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Semantics_PartType_descriptor();
inline const ::std::string& Semantics_PartType_Name(Semantics_PartType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Semantics_PartType_descriptor(), value);
}
inline bool Semantics_PartType_Parse(
    const ::std::string& name, Semantics_PartType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Semantics_PartType>(
    Semantics_PartType_descriptor(), name, value);
}
enum LinearConstraint_ConstraintSemantics {
  LinearConstraint_ConstraintSemantics_GENERAL = 1,
  LinearConstraint_ConstraintSemantics_SYMM_GROUND = 2,
  LinearConstraint_ConstraintSemantics_SYMM_LEGW = 3,
  LinearConstraint_ConstraintSemantics_SYMM_LEGL = 4,
  LinearConstraint_ConstraintSemantics_SYMM_SPACING = 5
};
bool LinearConstraint_ConstraintSemantics_IsValid(int value);
const LinearConstraint_ConstraintSemantics LinearConstraint_ConstraintSemantics_ConstraintSemantics_MIN = LinearConstraint_ConstraintSemantics_GENERAL;
const LinearConstraint_ConstraintSemantics LinearConstraint_ConstraintSemantics_ConstraintSemantics_MAX = LinearConstraint_ConstraintSemantics_SYMM_SPACING;
const int LinearConstraint_ConstraintSemantics_ConstraintSemantics_ARRAYSIZE = LinearConstraint_ConstraintSemantics_ConstraintSemantics_MAX + 1;

const ::google::protobuf::EnumDescriptor* LinearConstraint_ConstraintSemantics_descriptor();
inline const ::std::string& LinearConstraint_ConstraintSemantics_Name(LinearConstraint_ConstraintSemantics value) {
  return ::google::protobuf::internal::NameOfEnum(
    LinearConstraint_ConstraintSemantics_descriptor(), value);
}
inline bool LinearConstraint_ConstraintSemantics_Parse(
    const ::std::string& name, LinearConstraint_ConstraintSemantics* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LinearConstraint_ConstraintSemantics>(
    LinearConstraint_ConstraintSemantics_descriptor(), name, value);
}
enum LinearConstraint_Type {
  LinearConstraint_Type_EQUALITY = 1,
  LinearConstraint_Type_LESS_THAN_ZERO = 2
};
bool LinearConstraint_Type_IsValid(int value);
const LinearConstraint_Type LinearConstraint_Type_Type_MIN = LinearConstraint_Type_EQUALITY;
const LinearConstraint_Type LinearConstraint_Type_Type_MAX = LinearConstraint_Type_LESS_THAN_ZERO;
const int LinearConstraint_Type_Type_ARRAYSIZE = LinearConstraint_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LinearConstraint_Type_descriptor();
inline const ::std::string& LinearConstraint_Type_Name(LinearConstraint_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LinearConstraint_Type_descriptor(), value);
}
inline bool LinearConstraint_Type_Parse(
    const ::std::string& name, LinearConstraint_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LinearConstraint_Type>(
    LinearConstraint_Type_descriptor(), name, value);
}
// ===================================================================

class TemplateSet : public ::google::protobuf::Message {
 public:
  TemplateSet();
  virtual ~TemplateSet();

  TemplateSet(const TemplateSet& from);

  inline TemplateSet& operator=(const TemplateSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TemplateSet& default_instance();

  void Swap(TemplateSet* other);

  // implements Message ----------------------------------------------

  TemplateSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TemplateSet& from);
  void MergeFrom(const TemplateSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FabByExample.proto.Template template = 1;
  inline int template__size() const;
  inline void clear_template_();
  static const int kTemplateFieldNumber = 1;
  inline const ::FabByExample::proto::Template& template_(int index) const;
  inline ::FabByExample::proto::Template* mutable_template_(int index);
  inline ::FabByExample::proto::Template* add_template_();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Template >&
      template_() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Template >*
      mutable_template_();

  // optional int32 root_template_id = 2;
  inline bool has_root_template_id() const;
  inline void clear_root_template_id();
  static const int kRootTemplateIdFieldNumber = 2;
  inline ::google::protobuf::int32 root_template_id() const;
  inline void set_root_template_id(::google::protobuf::int32 value);

  // optional .FabByExample.proto.GaitInformation gaitInfo = 3;
  inline bool has_gaitinfo() const;
  inline void clear_gaitinfo();
  static const int kGaitInfoFieldNumber = 3;
  inline const ::FabByExample::proto::GaitInformation& gaitinfo() const;
  inline ::FabByExample::proto::GaitInformation* mutable_gaitinfo();
  inline ::FabByExample::proto::GaitInformation* release_gaitinfo();
  inline void set_allocated_gaitinfo(::FabByExample::proto::GaitInformation* gaitinfo);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.TemplateSet)
 private:
  inline void set_has_root_template_id();
  inline void clear_has_root_template_id();
  inline void set_has_gaitinfo();
  inline void clear_has_gaitinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Template > template__;
  ::FabByExample::proto::GaitInformation* gaitinfo_;
  ::google::protobuf::int32 root_template_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static TemplateSet* default_instance_;
};
// -------------------------------------------------------------------

class GaitInformation : public ::google::protobuf::Message {
 public:
  GaitInformation();
  virtual ~GaitInformation();

  GaitInformation(const GaitInformation& from);

  inline GaitInformation& operator=(const GaitInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GaitInformation& default_instance();

  void Swap(GaitInformation* other);

  // implements Message ----------------------------------------------

  GaitInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GaitInformation& from);
  void MergeFrom(const GaitInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FabByExample.proto.SavedGait savedGaits = 1;
  inline int savedgaits_size() const;
  inline void clear_savedgaits();
  static const int kSavedGaitsFieldNumber = 1;
  inline const ::FabByExample::proto::SavedGait& savedgaits(int index) const;
  inline ::FabByExample::proto::SavedGait* mutable_savedgaits(int index);
  inline ::FabByExample::proto::SavedGait* add_savedgaits();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::SavedGait >&
      savedgaits() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::SavedGait >*
      mutable_savedgaits();

  // repeated int32 gaitSequence = 2;
  inline int gaitsequence_size() const;
  inline void clear_gaitsequence();
  static const int kGaitSequenceFieldNumber = 2;
  inline ::google::protobuf::int32 gaitsequence(int index) const;
  inline void set_gaitsequence(int index, ::google::protobuf::int32 value);
  inline void add_gaitsequence(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      gaitsequence() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_gaitsequence();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.GaitInformation)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::SavedGait > savedgaits_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > gaitsequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static GaitInformation* default_instance_;
};
// -------------------------------------------------------------------

class SavedGait : public ::google::protobuf::Message {
 public:
  SavedGait();
  virtual ~SavedGait();

  SavedGait(const SavedGait& from);

  inline SavedGait& operator=(const SavedGait& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SavedGait& default_instance();

  void Swap(SavedGait* other);

  // implements Message ----------------------------------------------

  SavedGait* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SavedGait& from);
  void MergeFrom(const SavedGait& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional double desiredDirection = 2;
  inline bool has_desireddirection() const;
  inline void clear_desireddirection();
  static const int kDesiredDirectionFieldNumber = 2;
  inline double desireddirection() const;
  inline void set_desireddirection(double value);

  // repeated int32 jointInfo_id = 3;
  inline int jointinfo_id_size() const;
  inline void clear_jointinfo_id();
  static const int kJointInfoIdFieldNumber = 3;
  inline ::google::protobuf::int32 jointinfo_id(int index) const;
  inline void set_jointinfo_id(int index, ::google::protobuf::int32 value);
  inline void add_jointinfo_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      jointinfo_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_jointinfo_id();

  // repeated double jointInfo_angle = 4;
  inline int jointinfo_angle_size() const;
  inline void clear_jointinfo_angle();
  static const int kJointInfoAngleFieldNumber = 4;
  inline double jointinfo_angle(int index) const;
  inline void set_jointinfo_angle(int index, double value);
  inline void add_jointinfo_angle(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      jointinfo_angle() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_jointinfo_angle();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.SavedGait)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desireddirection();
  inline void clear_has_desireddirection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  double desireddirection_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > jointinfo_id_;
  ::google::protobuf::RepeatedField< double > jointinfo_angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static SavedGait* default_instance_;
};
// -------------------------------------------------------------------

class Template : public ::google::protobuf::Message {
 public:
  Template();
  virtual ~Template();

  Template(const Template& from);

  inline Template& operator=(const Template& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Template& default_instance();

  void Swap(Template* other);

  // implements Message ----------------------------------------------

  Template* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Template& from);
  void MergeFrom(const Template& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .FabByExample.proto.symbolic.Parameter parameter = 3;
  inline int parameter_size() const;
  inline void clear_parameter();
  static const int kParameterFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::Parameter& parameter(int index) const;
  inline ::FabByExample::proto::symbolic::Parameter* mutable_parameter(int index);
  inline ::FabByExample::proto::symbolic::Parameter* add_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Parameter >&
      parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Parameter >*
      mutable_parameter();

  // optional .FabByExample.proto.MappingFunction mapping_function = 4;
  inline bool has_mapping_function() const;
  inline void clear_mapping_function();
  static const int kMappingFunctionFieldNumber = 4;
  inline const ::FabByExample::proto::MappingFunction& mapping_function() const;
  inline ::FabByExample::proto::MappingFunction* mutable_mapping_function();
  inline ::FabByExample::proto::MappingFunction* release_mapping_function();
  inline void set_allocated_mapping_function(::FabByExample::proto::MappingFunction* mapping_function);

  // optional .FabByExample.proto.FeasibleSet feasible_set = 5;
  inline bool has_feasible_set() const;
  inline void clear_feasible_set();
  static const int kFeasibleSetFieldNumber = 5;
  inline const ::FabByExample::proto::FeasibleSet& feasible_set() const;
  inline ::FabByExample::proto::FeasibleSet* mutable_feasible_set();
  inline ::FabByExample::proto::FeasibleSet* release_feasible_set();
  inline void set_allocated_feasible_set(::FabByExample::proto::FeasibleSet* feasible_set);

  // repeated int32 child_template_id = 6;
  inline int child_template_id_size() const;
  inline void clear_child_template_id();
  static const int kChildTemplateIdFieldNumber = 6;
  inline ::google::protobuf::int32 child_template_id(int index) const;
  inline void set_child_template_id(int index, ::google::protobuf::int32 value);
  inline void add_child_template_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      child_template_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_child_template_id();

  // repeated .FabByExample.proto.Connection connection = 7;
  inline int connection_size() const;
  inline void clear_connection();
  static const int kConnectionFieldNumber = 7;
  inline const ::FabByExample::proto::Connection& connection(int index) const;
  inline ::FabByExample::proto::Connection* mutable_connection(int index);
  inline ::FabByExample::proto::Connection* add_connection();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Connection >&
      connection() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Connection >*
      mutable_connection();

  // repeated .FabByExample.proto.Patch patch = 8;
  inline int patch_size() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 8;
  inline const ::FabByExample::proto::Patch& patch(int index) const;
  inline ::FabByExample::proto::Patch* mutable_patch(int index);
  inline ::FabByExample::proto::Patch* add_patch();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Patch >&
      patch() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Patch >*
      mutable_patch();

  // optional bool independent = 9;
  inline bool has_independent() const;
  inline void clear_independent();
  static const int kIndependentFieldNumber = 9;
  inline bool independent() const;
  inline void set_independent(bool value);

  // optional .FabByExample.proto.Semantics semantics = 10;
  inline bool has_semantics() const;
  inline void clear_semantics();
  static const int kSemanticsFieldNumber = 10;
  inline const ::FabByExample::proto::Semantics& semantics() const;
  inline ::FabByExample::proto::Semantics* mutable_semantics();
  inline ::FabByExample::proto::Semantics* release_semantics();
  inline void set_allocated_semantics(::FabByExample::proto::Semantics* semantics);

  // repeated .FabByExample.proto.symbolic.Point3S contactPoints = 11;
  inline int contactpoints_size() const;
  inline void clear_contactpoints();
  static const int kContactPointsFieldNumber = 11;
  inline const ::FabByExample::proto::symbolic::Point3S& contactpoints(int index) const;
  inline ::FabByExample::proto::symbolic::Point3S* mutable_contactpoints(int index);
  inline ::FabByExample::proto::symbolic::Point3S* add_contactpoints();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Point3S >&
      contactpoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Point3S >*
      mutable_contactpoints();

  // repeated .FabByExample.proto.ContactInfo contactInfo = 12;
  inline int contactinfo_size() const;
  inline void clear_contactinfo();
  static const int kContactInfoFieldNumber = 12;
  inline const ::FabByExample::proto::ContactInfo& contactinfo(int index) const;
  inline ::FabByExample::proto::ContactInfo* mutable_contactinfo(int index);
  inline ::FabByExample::proto::ContactInfo* add_contactinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::ContactInfo >&
      contactinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::ContactInfo >*
      mutable_contactinfo();

  // optional .FabByExample.proto.SymmetryChoices symmetryChoices = 13;
  inline bool has_symmetrychoices() const;
  inline void clear_symmetrychoices();
  static const int kSymmetryChoicesFieldNumber = 13;
  inline const ::FabByExample::proto::SymmetryChoices& symmetrychoices() const;
  inline ::FabByExample::proto::SymmetryChoices* mutable_symmetrychoices();
  inline ::FabByExample::proto::SymmetryChoices* release_symmetrychoices();
  inline void set_allocated_symmetrychoices(::FabByExample::proto::SymmetryChoices* symmetrychoices);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.Template)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_mapping_function();
  inline void clear_has_mapping_function();
  inline void set_has_feasible_set();
  inline void clear_has_feasible_set();
  inline void set_has_independent();
  inline void clear_has_independent();
  inline void set_has_semantics();
  inline void clear_has_semantics();
  inline void set_has_symmetrychoices();
  inline void clear_has_symmetrychoices();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Parameter > parameter_;
  ::FabByExample::proto::MappingFunction* mapping_function_;
  ::FabByExample::proto::FeasibleSet* feasible_set_;
  ::google::protobuf::int32 id_;
  bool independent_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > child_template_id_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Connection > connection_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Patch > patch_;
  ::FabByExample::proto::Semantics* semantics_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Point3S > contactpoints_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::ContactInfo > contactinfo_;
  ::FabByExample::proto::SymmetryChoices* symmetrychoices_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static Template* default_instance_;
};
// -------------------------------------------------------------------

class ContactInfo : public ::google::protobuf::Message {
 public:
  ContactInfo();
  virtual ~ContactInfo();

  ContactInfo(const ContactInfo& from);

  inline ContactInfo& operator=(const ContactInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactInfo& default_instance();

  void Swap(ContactInfo* other);

  // implements Message ----------------------------------------------

  ContactInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContactInfo& from);
  void MergeFrom(const ContactInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.Point3S point = 1;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::Point3S& point() const;
  inline ::FabByExample::proto::symbolic::Point3S* mutable_point();
  inline ::FabByExample::proto::symbolic::Point3S* release_point();
  inline void set_allocated_point(::FabByExample::proto::symbolic::Point3S* point);

  // optional bool hasBeenConstraint = 2;
  inline bool has_hasbeenconstraint() const;
  inline void clear_hasbeenconstraint();
  static const int kHasBeenConstraintFieldNumber = 2;
  inline bool hasbeenconstraint() const;
  inline void set_hasbeenconstraint(bool value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.ContactInfo)
 private:
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_hasbeenconstraint();
  inline void clear_has_hasbeenconstraint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::Point3S* point_;
  bool hasbeenconstraint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static ContactInfo* default_instance_;
};
// -------------------------------------------------------------------

class SymmetryChoices : public ::google::protobuf::Message {
 public:
  SymmetryChoices();
  virtual ~SymmetryChoices();

  SymmetryChoices(const SymmetryChoices& from);

  inline SymmetryChoices& operator=(const SymmetryChoices& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymmetryChoices& default_instance();

  void Swap(SymmetryChoices* other);

  // implements Message ----------------------------------------------

  SymmetryChoices* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymmetryChoices& from);
  void MergeFrom(const SymmetryChoices& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool symm_ground = 1;
  inline bool has_symm_ground() const;
  inline void clear_symm_ground();
  static const int kSymmGroundFieldNumber = 1;
  inline bool symm_ground() const;
  inline void set_symm_ground(bool value);

  // optional bool symm_legW = 2;
  inline bool has_symm_legw() const;
  inline void clear_symm_legw();
  static const int kSymmLegWFieldNumber = 2;
  inline bool symm_legw() const;
  inline void set_symm_legw(bool value);

  // optional bool symm_legL = 3;
  inline bool has_symm_legl() const;
  inline void clear_symm_legl();
  static const int kSymmLegLFieldNumber = 3;
  inline bool symm_legl() const;
  inline void set_symm_legl(bool value);

  // optional bool symm_spacing = 4;
  inline bool has_symm_spacing() const;
  inline void clear_symm_spacing();
  static const int kSymmSpacingFieldNumber = 4;
  inline bool symm_spacing() const;
  inline void set_symm_spacing(bool value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.SymmetryChoices)
 private:
  inline void set_has_symm_ground();
  inline void clear_has_symm_ground();
  inline void set_has_symm_legw();
  inline void clear_has_symm_legw();
  inline void set_has_symm_legl();
  inline void clear_has_symm_legl();
  inline void set_has_symm_spacing();
  inline void clear_has_symm_spacing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool symm_ground_;
  bool symm_legw_;
  bool symm_legl_;
  bool symm_spacing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static SymmetryChoices* default_instance_;
};
// -------------------------------------------------------------------

class Semantics : public ::google::protobuf::Message {
 public:
  Semantics();
  virtual ~Semantics();

  Semantics(const Semantics& from);

  inline Semantics& operator=(const Semantics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Semantics& default_instance();

  void Swap(Semantics* other);

  // implements Message ----------------------------------------------

  Semantics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Semantics& from);
  void MergeFrom(const Semantics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Semantics_PrintMethod PrintMethod;
  static const PrintMethod PRINT_AND_FOLD = Semantics_PrintMethod_PRINT_AND_FOLD;
  static const PrintMethod DIRECT_3D = Semantics_PrintMethod_DIRECT_3D;
  static inline bool PrintMethod_IsValid(int value) {
    return Semantics_PrintMethod_IsValid(value);
  }
  static const PrintMethod PrintMethod_MIN =
    Semantics_PrintMethod_PrintMethod_MIN;
  static const PrintMethod PrintMethod_MAX =
    Semantics_PrintMethod_PrintMethod_MAX;
  static const int PrintMethod_ARRAYSIZE =
    Semantics_PrintMethod_PrintMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PrintMethod_descriptor() {
    return Semantics_PrintMethod_descriptor();
  }
  static inline const ::std::string& PrintMethod_Name(PrintMethod value) {
    return Semantics_PrintMethod_Name(value);
  }
  static inline bool PrintMethod_Parse(const ::std::string& name,
      PrintMethod* value) {
    return Semantics_PrintMethod_Parse(name, value);
  }

  typedef Semantics_PartType PartType;
  static const PartType LEG = Semantics_PartType_LEG;
  static const PartType BODY = Semantics_PartType_BODY;
  static const PartType PERIPHERAL = Semantics_PartType_PERIPHERAL;
  static const PartType FACE = Semantics_PartType_FACE;
  static const PartType GENERAL = Semantics_PartType_GENERAL;
  static const PartType WHEEL = Semantics_PartType_WHEEL;
  static inline bool PartType_IsValid(int value) {
    return Semantics_PartType_IsValid(value);
  }
  static const PartType PartType_MIN =
    Semantics_PartType_PartType_MIN;
  static const PartType PartType_MAX =
    Semantics_PartType_PartType_MAX;
  static const int PartType_ARRAYSIZE =
    Semantics_PartType_PartType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PartType_descriptor() {
    return Semantics_PartType_descriptor();
  }
  static inline const ::std::string& PartType_Name(PartType value) {
    return Semantics_PartType_Name(value);
  }
  static inline bool PartType_Parse(const ::std::string& name,
      PartType* value) {
    return Semantics_PartType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.Semantics.PrintMethod printMethod = 1;
  inline bool has_printmethod() const;
  inline void clear_printmethod();
  static const int kPrintMethodFieldNumber = 1;
  inline ::FabByExample::proto::Semantics_PrintMethod printmethod() const;
  inline void set_printmethod(::FabByExample::proto::Semantics_PrintMethod value);

  // optional .FabByExample.proto.Semantics.PartType partType = 2;
  inline bool has_parttype() const;
  inline void clear_parttype();
  static const int kPartTypeFieldNumber = 2;
  inline ::FabByExample::proto::Semantics_PartType parttype() const;
  inline void set_parttype(::FabByExample::proto::Semantics_PartType value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.Semantics)
 private:
  inline void set_has_printmethod();
  inline void clear_has_printmethod();
  inline void set_has_parttype();
  inline void clear_has_parttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int printmethod_;
  int parttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static Semantics* default_instance_;
};
// -------------------------------------------------------------------

class Patch : public ::google::protobuf::Message {
 public:
  Patch();
  virtual ~Patch();

  Patch(const Patch& from);

  inline Patch& operator=(const Patch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Patch& default_instance();

  void Swap(Patch* other);

  // implements Message ----------------------------------------------

  Patch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Patch& from);
  void MergeFrom(const Patch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .FabByExample.proto.Edge2SPatch edge2SPatch = 2;
  inline bool has_edge2spatch() const;
  inline void clear_edge2spatch();
  static const int kEdge2SPatchFieldNumber = 2;
  inline const ::FabByExample::proto::Edge2SPatch& edge2spatch() const;
  inline ::FabByExample::proto::Edge2SPatch* mutable_edge2spatch();
  inline ::FabByExample::proto::Edge2SPatch* release_edge2spatch();
  inline void set_allocated_edge2spatch(::FabByExample::proto::Edge2SPatch* edge2spatch);

  // optional .FabByExample.proto.ServoPointPatch servoPointPatch = 3;
  inline bool has_servopointpatch() const;
  inline void clear_servopointpatch();
  static const int kServoPointPatchFieldNumber = 3;
  inline const ::FabByExample::proto::ServoPointPatch& servopointpatch() const;
  inline ::FabByExample::proto::ServoPointPatch* mutable_servopointpatch();
  inline ::FabByExample::proto::ServoPointPatch* release_servopointpatch();
  inline void set_allocated_servopointpatch(::FabByExample::proto::ServoPointPatch* servopointpatch);

  // optional .FabByExample.proto.ServoLinePatch servoLinePatch = 4;
  inline bool has_servolinepatch() const;
  inline void clear_servolinepatch();
  static const int kServoLinePatchFieldNumber = 4;
  inline const ::FabByExample::proto::ServoLinePatch& servolinepatch() const;
  inline ::FabByExample::proto::ServoLinePatch* mutable_servolinepatch();
  inline ::FabByExample::proto::ServoLinePatch* release_servolinepatch();
  inline void set_allocated_servolinepatch(::FabByExample::proto::ServoLinePatch* servolinepatch);

  // optional .FabByExample.proto.PeripheralPatch peripheralpatch = 5;
  inline bool has_peripheralpatch() const;
  inline void clear_peripheralpatch();
  static const int kPeripheralpatchFieldNumber = 5;
  inline const ::FabByExample::proto::PeripheralPatch& peripheralpatch() const;
  inline ::FabByExample::proto::PeripheralPatch* mutable_peripheralpatch();
  inline ::FabByExample::proto::PeripheralPatch* release_peripheralpatch();
  inline void set_allocated_peripheralpatch(::FabByExample::proto::PeripheralPatch* peripheralpatch);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.Patch)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_edge2spatch();
  inline void clear_has_edge2spatch();
  inline void set_has_servopointpatch();
  inline void clear_has_servopointpatch();
  inline void set_has_servolinepatch();
  inline void clear_has_servolinepatch();
  inline void set_has_peripheralpatch();
  inline void clear_has_peripheralpatch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::Edge2SPatch* edge2spatch_;
  ::FabByExample::proto::ServoPointPatch* servopointpatch_;
  ::FabByExample::proto::ServoLinePatch* servolinepatch_;
  ::FabByExample::proto::PeripheralPatch* peripheralpatch_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static Patch* default_instance_;
};
// -------------------------------------------------------------------

class ServoPointPatch : public ::google::protobuf::Message {
 public:
  ServoPointPatch();
  virtual ~ServoPointPatch();

  ServoPointPatch(const ServoPointPatch& from);

  inline ServoPointPatch& operator=(const ServoPointPatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServoPointPatch& default_instance();

  void Swap(ServoPointPatch* other);

  // implements Message ----------------------------------------------

  ServoPointPatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServoPointPatch& from);
  void MergeFrom(const ServoPointPatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.Point3S center = 1;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::Point3S& center() const;
  inline ::FabByExample::proto::symbolic::Point3S* mutable_center();
  inline ::FabByExample::proto::symbolic::Point3S* release_center();
  inline void set_allocated_center(::FabByExample::proto::symbolic::Point3S* center);

  // repeated double normal = 2;
  inline int normal_size() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 2;
  inline double normal(int index) const;
  inline void set_normal(int index, double value);
  inline void add_normal(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      normal() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_normal();

  // optional .FabByExample.proto.symbolic.LinearExpr separation = 3;
  inline bool has_separation() const;
  inline void clear_separation();
  static const int kSeparationFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::LinearExpr& separation() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_separation();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_separation();
  inline void set_allocated_separation(::FabByExample::proto::symbolic::LinearExpr* separation);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.ServoPointPatch)
 private:
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_separation();
  inline void clear_has_separation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::Point3S* center_;
  ::google::protobuf::RepeatedField< double > normal_;
  ::FabByExample::proto::symbolic::LinearExpr* separation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static ServoPointPatch* default_instance_;
};
// -------------------------------------------------------------------

class ServoSpacingInfo : public ::google::protobuf::Message {
 public:
  ServoSpacingInfo();
  virtual ~ServoSpacingInfo();

  ServoSpacingInfo(const ServoSpacingInfo& from);

  inline ServoSpacingInfo& operator=(const ServoSpacingInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServoSpacingInfo& default_instance();

  void Swap(ServoSpacingInfo* other);

  // implements Message ----------------------------------------------

  ServoSpacingInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServoSpacingInfo& from);
  void MergeFrom(const ServoSpacingInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.LinearExpr alpha = 1;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::LinearExpr& alpha() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_alpha();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_alpha();
  inline void set_allocated_alpha(::FabByExample::proto::symbolic::LinearExpr* alpha);

  // optional .FabByExample.proto.symbolic.LinearExpr separation_h = 2;
  inline bool has_separation_h() const;
  inline void clear_separation_h();
  static const int kSeparationHFieldNumber = 2;
  inline const ::FabByExample::proto::symbolic::LinearExpr& separation_h() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_separation_h();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_separation_h();
  inline void set_allocated_separation_h(::FabByExample::proto::symbolic::LinearExpr* separation_h);

  // repeated .FabByExample.proto.symbolic.LinearExpr separation_w = 3;
  inline int separation_w_size() const;
  inline void clear_separation_w();
  static const int kSeparationWFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::LinearExpr& separation_w(int index) const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_separation_w(int index);
  inline ::FabByExample::proto::symbolic::LinearExpr* add_separation_w();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >&
      separation_w() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >*
      mutable_separation_w();

  // repeated int32 associatedTemplates = 4;
  inline int associatedtemplates_size() const;
  inline void clear_associatedtemplates();
  static const int kAssociatedTemplatesFieldNumber = 4;
  inline ::google::protobuf::int32 associatedtemplates(int index) const;
  inline void set_associatedtemplates(int index, ::google::protobuf::int32 value);
  inline void add_associatedtemplates(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      associatedtemplates() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_associatedtemplates();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.ServoSpacingInfo)
 private:
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_separation_h();
  inline void clear_has_separation_h();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::LinearExpr* alpha_;
  ::FabByExample::proto::symbolic::LinearExpr* separation_h_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr > separation_w_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > associatedtemplates_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static ServoSpacingInfo* default_instance_;
};
// -------------------------------------------------------------------

class ServoLinePatch : public ::google::protobuf::Message {
 public:
  ServoLinePatch();
  virtual ~ServoLinePatch();

  ServoLinePatch(const ServoLinePatch& from);

  inline ServoLinePatch& operator=(const ServoLinePatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServoLinePatch& default_instance();

  void Swap(ServoLinePatch* other);

  // implements Message ----------------------------------------------

  ServoLinePatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServoLinePatch& from);
  void MergeFrom(const ServoLinePatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.Point3S startPoint = 1;
  inline bool has_startpoint() const;
  inline void clear_startpoint();
  static const int kStartPointFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::Point3S& startpoint() const;
  inline ::FabByExample::proto::symbolic::Point3S* mutable_startpoint();
  inline ::FabByExample::proto::symbolic::Point3S* release_startpoint();
  inline void set_allocated_startpoint(::FabByExample::proto::symbolic::Point3S* startpoint);

  // optional .FabByExample.proto.symbolic.Point3S endPoint = 2;
  inline bool has_endpoint() const;
  inline void clear_endpoint();
  static const int kEndPointFieldNumber = 2;
  inline const ::FabByExample::proto::symbolic::Point3S& endpoint() const;
  inline ::FabByExample::proto::symbolic::Point3S* mutable_endpoint();
  inline ::FabByExample::proto::symbolic::Point3S* release_endpoint();
  inline void set_allocated_endpoint(::FabByExample::proto::symbolic::Point3S* endpoint);

  // repeated double normal = 3;
  inline int normal_size() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 3;
  inline double normal(int index) const;
  inline void set_normal(int index, double value);
  inline void add_normal(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      normal() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_normal();

  // repeated .FabByExample.proto.ServoSpacingInfo servospacing = 4;
  inline int servospacing_size() const;
  inline void clear_servospacing();
  static const int kServospacingFieldNumber = 4;
  inline const ::FabByExample::proto::ServoSpacingInfo& servospacing(int index) const;
  inline ::FabByExample::proto::ServoSpacingInfo* mutable_servospacing(int index);
  inline ::FabByExample::proto::ServoSpacingInfo* add_servospacing();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::ServoSpacingInfo >&
      servospacing() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::ServoSpacingInfo >*
      mutable_servospacing();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.ServoLinePatch)
 private:
  inline void set_has_startpoint();
  inline void clear_has_startpoint();
  inline void set_has_endpoint();
  inline void clear_has_endpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::Point3S* startpoint_;
  ::FabByExample::proto::symbolic::Point3S* endpoint_;
  ::google::protobuf::RepeatedField< double > normal_;
  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::ServoSpacingInfo > servospacing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static ServoLinePatch* default_instance_;
};
// -------------------------------------------------------------------

class PeripheralPatch : public ::google::protobuf::Message {
 public:
  PeripheralPatch();
  virtual ~PeripheralPatch();

  PeripheralPatch(const PeripheralPatch& from);

  inline PeripheralPatch& operator=(const PeripheralPatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PeripheralPatch& default_instance();

  void Swap(PeripheralPatch* other);

  // implements Message ----------------------------------------------

  PeripheralPatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeripheralPatch& from);
  void MergeFrom(const PeripheralPatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 edgeId1 = 1;
  inline bool has_edgeid1() const;
  inline void clear_edgeid1();
  static const int kEdgeId1FieldNumber = 1;
  inline ::google::protobuf::int32 edgeid1() const;
  inline void set_edgeid1(::google::protobuf::int32 value);

  // optional int32 edgeId2 = 2;
  inline bool has_edgeid2() const;
  inline void clear_edgeid2();
  static const int kEdgeId2FieldNumber = 2;
  inline ::google::protobuf::int32 edgeid2() const;
  inline void set_edgeid2(::google::protobuf::int32 value);

  // repeated double normal = 3;
  inline int normal_size() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 3;
  inline double normal(int index) const;
  inline void set_normal(int index, double value);
  inline void add_normal(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      normal() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_normal();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.PeripheralPatch)
 private:
  inline void set_has_edgeid1();
  inline void clear_has_edgeid1();
  inline void set_has_edgeid2();
  inline void clear_has_edgeid2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 edgeid1_;
  ::google::protobuf::int32 edgeid2_;
  ::google::protobuf::RepeatedField< double > normal_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static PeripheralPatch* default_instance_;
};
// -------------------------------------------------------------------

class Edge2SPatch : public ::google::protobuf::Message {
 public:
  Edge2SPatch();
  virtual ~Edge2SPatch();

  Edge2SPatch(const Edge2SPatch& from);

  inline Edge2SPatch& operator=(const Edge2SPatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge2SPatch& default_instance();

  void Swap(Edge2SPatch* other);

  // implements Message ----------------------------------------------

  Edge2SPatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edge2SPatch& from);
  void MergeFrom(const Edge2SPatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 edgeId = 1;
  inline bool has_edgeid() const;
  inline void clear_edgeid();
  static const int kEdgeIdFieldNumber = 1;
  inline ::google::protobuf::int32 edgeid() const;
  inline void set_edgeid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.Edge2SPatch)
 private:
  inline void set_has_edgeid();
  inline void clear_has_edgeid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 edgeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static Edge2SPatch* default_instance_;
};
// -------------------------------------------------------------------

class Connection : public ::google::protobuf::Message {
 public:
  Connection();
  virtual ~Connection();

  Connection(const Connection& from);

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Connection& default_instance();

  void Swap(Connection* other);

  // implements Message ----------------------------------------------

  Connection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Connection& from);
  void MergeFrom(const Connection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 parentPatchRef = 1;
  inline bool has_parentpatchref() const;
  inline void clear_parentpatchref();
  static const int kParentPatchRefFieldNumber = 1;
  inline ::google::protobuf::int32 parentpatchref() const;
  inline void set_parentpatchref(::google::protobuf::int32 value);

  // repeated int32 patchRef = 2;
  inline int patchref_size() const;
  inline void clear_patchref();
  static const int kPatchRefFieldNumber = 2;
  inline ::google::protobuf::int32 patchref(int index) const;
  inline void set_patchref(int index, ::google::protobuf::int32 value);
  inline void add_patchref(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      patchref() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_patchref();

  // optional .FabByExample.proto.ConnectionMode connectionMode = 3;
  inline bool has_connectionmode() const;
  inline void clear_connectionmode();
  static const int kConnectionModeFieldNumber = 3;
  inline const ::FabByExample::proto::ConnectionMode& connectionmode() const;
  inline ::FabByExample::proto::ConnectionMode* mutable_connectionmode();
  inline ::FabByExample::proto::ConnectionMode* release_connectionmode();
  inline void set_allocated_connectionmode(::FabByExample::proto::ConnectionMode* connectionmode);

  // optional .FabByExample.proto.JointConnection jointConnection = 4;
  inline bool has_jointconnection() const;
  inline void clear_jointconnection();
  static const int kJointConnectionFieldNumber = 4;
  inline const ::FabByExample::proto::JointConnection& jointconnection() const;
  inline ::FabByExample::proto::JointConnection* mutable_jointconnection();
  inline ::FabByExample::proto::JointConnection* release_jointconnection();
  inline void set_allocated_jointconnection(::FabByExample::proto::JointConnection* jointconnection);

  // optional .FabByExample.proto.FillConnection fillConnection = 5;
  inline bool has_fillconnection() const;
  inline void clear_fillconnection();
  static const int kFillConnectionFieldNumber = 5;
  inline const ::FabByExample::proto::FillConnection& fillconnection() const;
  inline ::FabByExample::proto::FillConnection* mutable_fillconnection();
  inline ::FabByExample::proto::FillConnection* release_fillconnection();
  inline void set_allocated_fillconnection(::FabByExample::proto::FillConnection* fillconnection);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.Connection)
 private:
  inline void set_has_parentpatchref();
  inline void clear_has_parentpatchref();
  inline void set_has_connectionmode();
  inline void clear_has_connectionmode();
  inline void set_has_jointconnection();
  inline void clear_has_jointconnection();
  inline void set_has_fillconnection();
  inline void clear_has_fillconnection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > patchref_;
  ::FabByExample::proto::ConnectionMode* connectionmode_;
  ::FabByExample::proto::JointConnection* jointconnection_;
  ::FabByExample::proto::FillConnection* fillconnection_;
  ::google::protobuf::int32 parentpatchref_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static Connection* default_instance_;
};
// -------------------------------------------------------------------

class ConnectionMode : public ::google::protobuf::Message {
 public:
  ConnectionMode();
  virtual ~ConnectionMode();

  ConnectionMode(const ConnectionMode& from);

  inline ConnectionMode& operator=(const ConnectionMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionMode& default_instance();

  void Swap(ConnectionMode* other);

  // implements Message ----------------------------------------------

  ConnectionMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectionMode& from);
  void MergeFrom(const ConnectionMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.FoldConnection foldConnection = 1;
  inline bool has_foldconnection() const;
  inline void clear_foldconnection();
  static const int kFoldConnectionFieldNumber = 1;
  inline const ::FabByExample::proto::FoldConnection& foldconnection() const;
  inline ::FabByExample::proto::FoldConnection* mutable_foldconnection();
  inline ::FabByExample::proto::FoldConnection* release_foldconnection();
  inline void set_allocated_foldconnection(::FabByExample::proto::FoldConnection* foldconnection);

  // optional .FabByExample.proto.BendConnection bendConnection = 2;
  inline bool has_bendconnection() const;
  inline void clear_bendconnection();
  static const int kBendConnectionFieldNumber = 2;
  inline const ::FabByExample::proto::BendConnection& bendconnection() const;
  inline ::FabByExample::proto::BendConnection* mutable_bendconnection();
  inline ::FabByExample::proto::BendConnection* release_bendconnection();
  inline void set_allocated_bendconnection(::FabByExample::proto::BendConnection* bendconnection);

  // optional .FabByExample.proto.FlexConnection flexConnection = 3;
  inline bool has_flexconnection() const;
  inline void clear_flexconnection();
  static const int kFlexConnectionFieldNumber = 3;
  inline const ::FabByExample::proto::FlexConnection& flexconnection() const;
  inline ::FabByExample::proto::FlexConnection* mutable_flexconnection();
  inline ::FabByExample::proto::FlexConnection* release_flexconnection();
  inline void set_allocated_flexconnection(::FabByExample::proto::FlexConnection* flexconnection);

  // optional .FabByExample.proto.JointConnection jointConnection = 4;
  inline bool has_jointconnection() const;
  inline void clear_jointconnection();
  static const int kJointConnectionFieldNumber = 4;
  inline const ::FabByExample::proto::JointConnection& jointconnection() const;
  inline ::FabByExample::proto::JointConnection* mutable_jointconnection();
  inline ::FabByExample::proto::JointConnection* release_jointconnection();
  inline void set_allocated_jointconnection(::FabByExample::proto::JointConnection* jointconnection);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.ConnectionMode)
 private:
  inline void set_has_foldconnection();
  inline void clear_has_foldconnection();
  inline void set_has_bendconnection();
  inline void clear_has_bendconnection();
  inline void set_has_flexconnection();
  inline void clear_has_flexconnection();
  inline void set_has_jointconnection();
  inline void clear_has_jointconnection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::FoldConnection* foldconnection_;
  ::FabByExample::proto::BendConnection* bendconnection_;
  ::FabByExample::proto::FlexConnection* flexconnection_;
  ::FabByExample::proto::JointConnection* jointconnection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static ConnectionMode* default_instance_;
};
// -------------------------------------------------------------------

class FoldConnection : public ::google::protobuf::Message {
 public:
  FoldConnection();
  virtual ~FoldConnection();

  FoldConnection(const FoldConnection& from);

  inline FoldConnection& operator=(const FoldConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FoldConnection& default_instance();

  void Swap(FoldConnection* other);

  // implements Message ----------------------------------------------

  FoldConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FoldConnection& from);
  void MergeFrom(const FoldConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double angle = 1;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 1;
  inline double angle() const;
  inline void set_angle(double value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.FoldConnection)
 private:
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static FoldConnection* default_instance_;
};
// -------------------------------------------------------------------

class JointConnection : public ::google::protobuf::Message {
 public:
  JointConnection();
  virtual ~JointConnection();

  JointConnection(const JointConnection& from);

  inline JointConnection& operator=(const JointConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JointConnection& default_instance();

  void Swap(JointConnection* other);

  // implements Message ----------------------------------------------

  JointConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JointConnection& from);
  void MergeFrom(const JointConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double angle = 1;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 1;
  inline double angle() const;
  inline void set_angle(double value);

  // optional .FabByExample.proto.Articulation articulations = 2;
  inline bool has_articulations() const;
  inline void clear_articulations();
  static const int kArticulationsFieldNumber = 2;
  inline const ::FabByExample::proto::Articulation& articulations() const;
  inline ::FabByExample::proto::Articulation* mutable_articulations();
  inline ::FabByExample::proto::Articulation* release_articulations();
  inline void set_allocated_articulations(::FabByExample::proto::Articulation* articulations);

  // optional .FabByExample.proto.PrintType printType = 3;
  inline bool has_printtype() const;
  inline void clear_printtype();
  static const int kPrintTypeFieldNumber = 3;
  inline const ::FabByExample::proto::PrintType& printtype() const;
  inline ::FabByExample::proto::PrintType* mutable_printtype();
  inline ::FabByExample::proto::PrintType* release_printtype();
  inline void set_allocated_printtype(::FabByExample::proto::PrintType* printtype);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.JointConnection)
 private:
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_articulations();
  inline void clear_has_articulations();
  inline void set_has_printtype();
  inline void clear_has_printtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double angle_;
  ::FabByExample::proto::Articulation* articulations_;
  ::FabByExample::proto::PrintType* printtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static JointConnection* default_instance_;
};
// -------------------------------------------------------------------

class PrintType : public ::google::protobuf::Message {
 public:
  PrintType();
  virtual ~PrintType();

  PrintType(const PrintType& from);

  inline PrintType& operator=(const PrintType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrintType& default_instance();

  void Swap(PrintType* other);

  // implements Message ----------------------------------------------

  PrintType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrintType& from);
  void MergeFrom(const PrintType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool ballAndSocket = 1;
  inline bool has_ballandsocket() const;
  inline void clear_ballandsocket();
  static const int kBallAndSocketFieldNumber = 1;
  inline bool ballandsocket() const;
  inline void set_ballandsocket(bool value);

  // optional bool prismatic = 2;
  inline bool has_prismatic() const;
  inline void clear_prismatic();
  static const int kPrismaticFieldNumber = 2;
  inline bool prismatic() const;
  inline void set_prismatic(bool value);

  // optional bool revolute = 3;
  inline bool has_revolute() const;
  inline void clear_revolute();
  static const int kRevoluteFieldNumber = 3;
  inline bool revolute() const;
  inline void set_revolute(bool value);

  // optional bool none = 4;
  inline bool has_none() const;
  inline void clear_none();
  static const int kNoneFieldNumber = 4;
  inline bool none() const;
  inline void set_none(bool value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.PrintType)
 private:
  inline void set_has_ballandsocket();
  inline void clear_has_ballandsocket();
  inline void set_has_prismatic();
  inline void clear_has_prismatic();
  inline void set_has_revolute();
  inline void clear_has_revolute();
  inline void set_has_none();
  inline void clear_has_none();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool ballandsocket_;
  bool prismatic_;
  bool revolute_;
  bool none_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static PrintType* default_instance_;
};
// -------------------------------------------------------------------

class BendConnection : public ::google::protobuf::Message {
 public:
  BendConnection();
  virtual ~BendConnection();

  BendConnection(const BendConnection& from);

  inline BendConnection& operator=(const BendConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BendConnection& default_instance();

  void Swap(BendConnection* other);

  // implements Message ----------------------------------------------

  BendConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BendConnection& from);
  void MergeFrom(const BendConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double angle = 1;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 1;
  inline double angle() const;
  inline void set_angle(double value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.BendConnection)
 private:
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static BendConnection* default_instance_;
};
// -------------------------------------------------------------------

class FillConnection : public ::google::protobuf::Message {
 public:
  FillConnection();
  virtual ~FillConnection();

  FillConnection(const FillConnection& from);

  inline FillConnection& operator=(const FillConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FillConnection& default_instance();

  void Swap(FillConnection* other);

  // implements Message ----------------------------------------------

  FillConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FillConnection& from);
  void MergeFrom(const FillConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double angle = 1;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 1;
  inline double angle() const;
  inline void set_angle(double value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.FillConnection)
 private:
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static FillConnection* default_instance_;
};
// -------------------------------------------------------------------

class FlexConnection : public ::google::protobuf::Message {
 public:
  FlexConnection();
  virtual ~FlexConnection();

  FlexConnection(const FlexConnection& from);

  inline FlexConnection& operator=(const FlexConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlexConnection& default_instance();

  void Swap(FlexConnection* other);

  // implements Message ----------------------------------------------

  FlexConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlexConnection& from);
  void MergeFrom(const FlexConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double angle = 1;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 1;
  inline double angle() const;
  inline void set_angle(double value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.FlexConnection)
 private:
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static FlexConnection* default_instance_;
};
// -------------------------------------------------------------------

class MappingFunction : public ::google::protobuf::Message {
 public:
  MappingFunction();
  virtual ~MappingFunction();

  MappingFunction(const MappingFunction& from);

  inline MappingFunction& operator=(const MappingFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MappingFunction& default_instance();

  void Swap(MappingFunction* other);

  // implements Message ----------------------------------------------

  MappingFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MappingFunction& from);
  void MergeFrom(const MappingFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.LinearMappingFunction3 linear_3 = 1;
  inline bool has_linear_3() const;
  inline void clear_linear_3();
  static const int kLinear3FieldNumber = 1;
  inline const ::FabByExample::proto::LinearMappingFunction3& linear_3() const;
  inline ::FabByExample::proto::LinearMappingFunction3* mutable_linear_3();
  inline ::FabByExample::proto::LinearMappingFunction3* release_linear_3();
  inline void set_allocated_linear_3(::FabByExample::proto::LinearMappingFunction3* linear_3);

  // optional .FabByExample.proto.LinearMappingFunction2 linear_2 = 2;
  inline bool has_linear_2() const;
  inline void clear_linear_2();
  static const int kLinear2FieldNumber = 2;
  inline const ::FabByExample::proto::LinearMappingFunction2& linear_2() const;
  inline ::FabByExample::proto::LinearMappingFunction2* mutable_linear_2();
  inline ::FabByExample::proto::LinearMappingFunction2* release_linear_2();
  inline void set_allocated_linear_2(::FabByExample::proto::LinearMappingFunction2* linear_2);

  // optional .FabByExample.proto.CompositionMappingFunction composition = 3;
  inline bool has_composition() const;
  inline void clear_composition();
  static const int kCompositionFieldNumber = 3;
  inline const ::FabByExample::proto::CompositionMappingFunction& composition() const;
  inline ::FabByExample::proto::CompositionMappingFunction* mutable_composition();
  inline ::FabByExample::proto::CompositionMappingFunction* release_composition();
  inline void set_allocated_composition(::FabByExample::proto::CompositionMappingFunction* composition);

  // optional .FabByExample.proto.ExternalMeshAffineMappingFunction external_mesh_affine = 4;
  inline bool has_external_mesh_affine() const;
  inline void clear_external_mesh_affine();
  static const int kExternalMeshAffineFieldNumber = 4;
  inline const ::FabByExample::proto::ExternalMeshAffineMappingFunction& external_mesh_affine() const;
  inline ::FabByExample::proto::ExternalMeshAffineMappingFunction* mutable_external_mesh_affine();
  inline ::FabByExample::proto::ExternalMeshAffineMappingFunction* release_external_mesh_affine();
  inline void set_allocated_external_mesh_affine(::FabByExample::proto::ExternalMeshAffineMappingFunction* external_mesh_affine);

  // optional .FabByExample.proto.ScadMappingFunction scad = 5;
  inline bool has_scad() const;
  inline void clear_scad();
  static const int kScadFieldNumber = 5;
  inline const ::FabByExample::proto::ScadMappingFunction& scad() const;
  inline ::FabByExample::proto::ScadMappingFunction* mutable_scad();
  inline ::FabByExample::proto::ScadMappingFunction* release_scad();
  inline void set_allocated_scad(::FabByExample::proto::ScadMappingFunction* scad);

  // optional .FabByExample.proto.SymbolicWayPointsMappingFunction symbolicWayPointsMappingFunction = 6;
  inline bool has_symbolicwaypointsmappingfunction() const;
  inline void clear_symbolicwaypointsmappingfunction();
  static const int kSymbolicWayPointsMappingFunctionFieldNumber = 6;
  inline const ::FabByExample::proto::SymbolicWayPointsMappingFunction& symbolicwaypointsmappingfunction() const;
  inline ::FabByExample::proto::SymbolicWayPointsMappingFunction* mutable_symbolicwaypointsmappingfunction();
  inline ::FabByExample::proto::SymbolicWayPointsMappingFunction* release_symbolicwaypointsmappingfunction();
  inline void set_allocated_symbolicwaypointsmappingfunction(::FabByExample::proto::SymbolicWayPointsMappingFunction* symbolicwaypointsmappingfunction);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.MappingFunction)
 private:
  inline void set_has_linear_3();
  inline void clear_has_linear_3();
  inline void set_has_linear_2();
  inline void clear_has_linear_2();
  inline void set_has_composition();
  inline void clear_has_composition();
  inline void set_has_external_mesh_affine();
  inline void clear_has_external_mesh_affine();
  inline void set_has_scad();
  inline void clear_has_scad();
  inline void set_has_symbolicwaypointsmappingfunction();
  inline void clear_has_symbolicwaypointsmappingfunction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::LinearMappingFunction3* linear_3_;
  ::FabByExample::proto::LinearMappingFunction2* linear_2_;
  ::FabByExample::proto::CompositionMappingFunction* composition_;
  ::FabByExample::proto::ExternalMeshAffineMappingFunction* external_mesh_affine_;
  ::FabByExample::proto::ScadMappingFunction* scad_;
  ::FabByExample::proto::SymbolicWayPointsMappingFunction* symbolicwaypointsmappingfunction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static MappingFunction* default_instance_;
};
// -------------------------------------------------------------------

class SymbolicWayPointsMappingFunction : public ::google::protobuf::Message {
 public:
  SymbolicWayPointsMappingFunction();
  virtual ~SymbolicWayPointsMappingFunction();

  SymbolicWayPointsMappingFunction(const SymbolicWayPointsMappingFunction& from);

  inline SymbolicWayPointsMappingFunction& operator=(const SymbolicWayPointsMappingFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolicWayPointsMappingFunction& default_instance();

  void Swap(SymbolicWayPointsMappingFunction* other);

  // implements Message ----------------------------------------------

  SymbolicWayPointsMappingFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolicWayPointsMappingFunction& from);
  void MergeFrom(const SymbolicWayPointsMappingFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FabByExample.proto.SymbolicWayPoint symbolicWayPoint = 1;
  inline int symbolicwaypoint_size() const;
  inline void clear_symbolicwaypoint();
  static const int kSymbolicWayPointFieldNumber = 1;
  inline const ::FabByExample::proto::SymbolicWayPoint& symbolicwaypoint(int index) const;
  inline ::FabByExample::proto::SymbolicWayPoint* mutable_symbolicwaypoint(int index);
  inline ::FabByExample::proto::SymbolicWayPoint* add_symbolicwaypoint();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::SymbolicWayPoint >&
      symbolicwaypoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::SymbolicWayPoint >*
      mutable_symbolicwaypoint();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.SymbolicWayPointsMappingFunction)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::SymbolicWayPoint > symbolicwaypoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static SymbolicWayPointsMappingFunction* default_instance_;
};
// -------------------------------------------------------------------

class SymbolicWayPoint : public ::google::protobuf::Message {
 public:
  SymbolicWayPoint();
  virtual ~SymbolicWayPoint();

  SymbolicWayPoint(const SymbolicWayPoint& from);

  inline SymbolicWayPoint& operator=(const SymbolicWayPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolicWayPoint& default_instance();

  void Swap(SymbolicWayPoint* other);

  // implements Message ----------------------------------------------

  SymbolicWayPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolicWayPoint& from);
  void MergeFrom(const SymbolicWayPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.LinearExpr time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::LinearExpr& time() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_time();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_time();
  inline void set_allocated_time(::FabByExample::proto::symbolic::LinearExpr* time);

  // optional .FabByExample.proto.symbolic.LinearExpr value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::FabByExample::proto::symbolic::LinearExpr& value() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_value();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_value();
  inline void set_allocated_value(::FabByExample::proto::symbolic::LinearExpr* value);

  // optional bool contact = 3;
  inline bool has_contact() const;
  inline void clear_contact();
  static const int kContactFieldNumber = 3;
  inline bool contact() const;
  inline void set_contact(bool value);

  // optional bool ismoving = 4;
  inline bool has_ismoving() const;
  inline void clear_ismoving();
  static const int kIsmovingFieldNumber = 4;
  inline bool ismoving() const;
  inline void set_ismoving(bool value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.SymbolicWayPoint)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_contact();
  inline void clear_has_contact();
  inline void set_has_ismoving();
  inline void clear_has_ismoving();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::LinearExpr* time_;
  ::FabByExample::proto::symbolic::LinearExpr* value_;
  bool contact_;
  bool ismoving_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static SymbolicWayPoint* default_instance_;
};
// -------------------------------------------------------------------

class ScadMappingFunction : public ::google::protobuf::Message {
 public:
  ScadMappingFunction();
  virtual ~ScadMappingFunction();

  ScadMappingFunction(const ScadMappingFunction& from);

  inline ScadMappingFunction& operator=(const ScadMappingFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScadMappingFunction& default_instance();

  void Swap(ScadMappingFunction* other);

  // implements Message ----------------------------------------------

  ScadMappingFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScadMappingFunction& from);
  void MergeFrom(const ScadMappingFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string scad_filename = 1;
  inline bool has_scad_filename() const;
  inline void clear_scad_filename();
  static const int kScadFilenameFieldNumber = 1;
  inline const ::std::string& scad_filename() const;
  inline void set_scad_filename(const ::std::string& value);
  inline void set_scad_filename(const char* value);
  inline void set_scad_filename(const char* value, size_t size);
  inline ::std::string* mutable_scad_filename();
  inline ::std::string* release_scad_filename();
  inline void set_allocated_scad_filename(::std::string* scad_filename);

  // optional .FabByExample.proto.OpenscadDesign design = 2;
  inline bool has_design() const;
  inline void clear_design();
  static const int kDesignFieldNumber = 2;
  inline const ::FabByExample::proto::OpenscadDesign& design() const;
  inline ::FabByExample::proto::OpenscadDesign* mutable_design();
  inline ::FabByExample::proto::OpenscadDesign* release_design();
  inline void set_allocated_design(::FabByExample::proto::OpenscadDesign* design);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.ScadMappingFunction)
 private:
  inline void set_has_scad_filename();
  inline void clear_has_scad_filename();
  inline void set_has_design();
  inline void clear_has_design();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* scad_filename_;
  ::FabByExample::proto::OpenscadDesign* design_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static ScadMappingFunction* default_instance_;
};
// -------------------------------------------------------------------

class ExternalMeshAffineMappingFunction : public ::google::protobuf::Message {
 public:
  ExternalMeshAffineMappingFunction();
  virtual ~ExternalMeshAffineMappingFunction();

  ExternalMeshAffineMappingFunction(const ExternalMeshAffineMappingFunction& from);

  inline ExternalMeshAffineMappingFunction& operator=(const ExternalMeshAffineMappingFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalMeshAffineMappingFunction& default_instance();

  void Swap(ExternalMeshAffineMappingFunction* other);

  // implements Message ----------------------------------------------

  ExternalMeshAffineMappingFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExternalMeshAffineMappingFunction& from);
  void MergeFrom(const ExternalMeshAffineMappingFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string stl_filename = 1;
  inline bool has_stl_filename() const;
  inline void clear_stl_filename();
  static const int kStlFilenameFieldNumber = 1;
  inline const ::std::string& stl_filename() const;
  inline void set_stl_filename(const ::std::string& value);
  inline void set_stl_filename(const char* value);
  inline void set_stl_filename(const char* value, size_t size);
  inline ::std::string* mutable_stl_filename();
  inline ::std::string* release_stl_filename();
  inline void set_allocated_stl_filename(::std::string* stl_filename);

  // optional bytes stl_data = 2;
  inline bool has_stl_data() const;
  inline void clear_stl_data();
  static const int kStlDataFieldNumber = 2;
  inline const ::std::string& stl_data() const;
  inline void set_stl_data(const ::std::string& value);
  inline void set_stl_data(const char* value);
  inline void set_stl_data(const void* value, size_t size);
  inline ::std::string* mutable_stl_data();
  inline ::std::string* release_stl_data();
  inline void set_allocated_stl_data(::std::string* stl_data);

  // optional .FabByExample.proto.symbolic.AffineMatrix3S transform = 3;
  inline bool has_transform() const;
  inline void clear_transform();
  static const int kTransformFieldNumber = 3;
  inline const ::FabByExample::proto::symbolic::AffineMatrix3S& transform() const;
  inline ::FabByExample::proto::symbolic::AffineMatrix3S* mutable_transform();
  inline ::FabByExample::proto::symbolic::AffineMatrix3S* release_transform();
  inline void set_allocated_transform(::FabByExample::proto::symbolic::AffineMatrix3S* transform);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.ExternalMeshAffineMappingFunction)
 private:
  inline void set_has_stl_filename();
  inline void clear_has_stl_filename();
  inline void set_has_stl_data();
  inline void clear_has_stl_data();
  inline void set_has_transform();
  inline void clear_has_transform();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stl_filename_;
  ::std::string* stl_data_;
  ::FabByExample::proto::symbolic::AffineMatrix3S* transform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static ExternalMeshAffineMappingFunction* default_instance_;
};
// -------------------------------------------------------------------

class CompositionMappingFunction : public ::google::protobuf::Message {
 public:
  CompositionMappingFunction();
  virtual ~CompositionMappingFunction();

  CompositionMappingFunction(const CompositionMappingFunction& from);

  inline CompositionMappingFunction& operator=(const CompositionMappingFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompositionMappingFunction& default_instance();

  void Swap(CompositionMappingFunction* other);

  // implements Message ----------------------------------------------

  CompositionMappingFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompositionMappingFunction& from);
  void MergeFrom(const CompositionMappingFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 template_id = 1;
  inline int template_id_size() const;
  inline void clear_template_id();
  static const int kTemplateIdFieldNumber = 1;
  inline ::google::protobuf::int32 template_id(int index) const;
  inline void set_template_id(int index, ::google::protobuf::int32 value);
  inline void add_template_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      template_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_template_id();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.CompositionMappingFunction)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > template_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static CompositionMappingFunction* default_instance_;
};
// -------------------------------------------------------------------

class LinearMappingFunction3 : public ::google::protobuf::Message {
 public:
  LinearMappingFunction3();
  virtual ~LinearMappingFunction3();

  LinearMappingFunction3(const LinearMappingFunction3& from);

  inline LinearMappingFunction3& operator=(const LinearMappingFunction3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearMappingFunction3& default_instance();

  void Swap(LinearMappingFunction3* other);

  // implements Message ----------------------------------------------

  LinearMappingFunction3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinearMappingFunction3& from);
  void MergeFrom(const LinearMappingFunction3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.Mesh3S mesh = 1;
  inline bool has_mesh() const;
  inline void clear_mesh();
  static const int kMeshFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::Mesh3S& mesh() const;
  inline ::FabByExample::proto::symbolic::Mesh3S* mutable_mesh();
  inline ::FabByExample::proto::symbolic::Mesh3S* release_mesh();
  inline void set_allocated_mesh(::FabByExample::proto::symbolic::Mesh3S* mesh);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.LinearMappingFunction3)
 private:
  inline void set_has_mesh();
  inline void clear_has_mesh();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::Mesh3S* mesh_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static LinearMappingFunction3* default_instance_;
};
// -------------------------------------------------------------------

class LinearMappingFunction2 : public ::google::protobuf::Message {
 public:
  LinearMappingFunction2();
  virtual ~LinearMappingFunction2();

  LinearMappingFunction2(const LinearMappingFunction2& from);

  inline LinearMappingFunction2& operator=(const LinearMappingFunction2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearMappingFunction2& default_instance();

  void Swap(LinearMappingFunction2* other);

  // implements Message ----------------------------------------------

  LinearMappingFunction2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinearMappingFunction2& from);
  void MergeFrom(const LinearMappingFunction2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.Drawing2S drawing = 1;
  inline bool has_drawing() const;
  inline void clear_drawing();
  static const int kDrawingFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::Drawing2S& drawing() const;
  inline ::FabByExample::proto::symbolic::Drawing2S* mutable_drawing();
  inline ::FabByExample::proto::symbolic::Drawing2S* release_drawing();
  inline void set_allocated_drawing(::FabByExample::proto::symbolic::Drawing2S* drawing);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.LinearMappingFunction2)
 private:
  inline void set_has_drawing();
  inline void clear_has_drawing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::Drawing2S* drawing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static LinearMappingFunction2* default_instance_;
};
// -------------------------------------------------------------------

class FeasibleSet : public ::google::protobuf::Message {
 public:
  FeasibleSet();
  virtual ~FeasibleSet();

  FeasibleSet(const FeasibleSet& from);

  inline FeasibleSet& operator=(const FeasibleSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeasibleSet& default_instance();

  void Swap(FeasibleSet* other);

  // implements Message ----------------------------------------------

  FeasibleSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeasibleSet& from);
  void MergeFrom(const FeasibleSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.ConstraintList constraint_list = 1;
  inline bool has_constraint_list() const;
  inline void clear_constraint_list();
  static const int kConstraintListFieldNumber = 1;
  inline const ::FabByExample::proto::ConstraintList& constraint_list() const;
  inline ::FabByExample::proto::ConstraintList* mutable_constraint_list();
  inline ::FabByExample::proto::ConstraintList* release_constraint_list();
  inline void set_allocated_constraint_list(::FabByExample::proto::ConstraintList* constraint_list);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.FeasibleSet)
 private:
  inline void set_has_constraint_list();
  inline void clear_has_constraint_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::ConstraintList* constraint_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static FeasibleSet* default_instance_;
};
// -------------------------------------------------------------------

class ConstraintList : public ::google::protobuf::Message {
 public:
  ConstraintList();
  virtual ~ConstraintList();

  ConstraintList(const ConstraintList& from);

  inline ConstraintList& operator=(const ConstraintList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstraintList& default_instance();

  void Swap(ConstraintList* other);

  // implements Message ----------------------------------------------

  ConstraintList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConstraintList& from);
  void MergeFrom(const ConstraintList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FabByExample.proto.Constraint constraint = 1;
  inline int constraint_size() const;
  inline void clear_constraint();
  static const int kConstraintFieldNumber = 1;
  inline const ::FabByExample::proto::Constraint& constraint(int index) const;
  inline ::FabByExample::proto::Constraint* mutable_constraint(int index);
  inline ::FabByExample::proto::Constraint* add_constraint();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Constraint >&
      constraint() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Constraint >*
      mutable_constraint();

  // repeated int32 inherited_template_id = 2;
  inline int inherited_template_id_size() const;
  inline void clear_inherited_template_id();
  static const int kInheritedTemplateIdFieldNumber = 2;
  inline ::google::protobuf::int32 inherited_template_id(int index) const;
  inline void set_inherited_template_id(int index, ::google::protobuf::int32 value);
  inline void add_inherited_template_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      inherited_template_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_inherited_template_id();

  // @@protoc_insertion_point(class_scope:FabByExample.proto.ConstraintList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Constraint > constraint_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > inherited_template_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static ConstraintList* default_instance_;
};
// -------------------------------------------------------------------

class Constraint : public ::google::protobuf::Message {
 public:
  Constraint();
  virtual ~Constraint();

  Constraint(const Constraint& from);

  inline Constraint& operator=(const Constraint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Constraint& default_instance();

  void Swap(Constraint* other);

  // implements Message ----------------------------------------------

  Constraint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Constraint& from);
  void MergeFrom(const Constraint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.LinearConstraint linear_constraint = 1;
  inline bool has_linear_constraint() const;
  inline void clear_linear_constraint();
  static const int kLinearConstraintFieldNumber = 1;
  inline const ::FabByExample::proto::LinearConstraint& linear_constraint() const;
  inline ::FabByExample::proto::LinearConstraint* mutable_linear_constraint();
  inline ::FabByExample::proto::LinearConstraint* release_linear_constraint();
  inline void set_allocated_linear_constraint(::FabByExample::proto::LinearConstraint* linear_constraint);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.Constraint)
 private:
  inline void set_has_linear_constraint();
  inline void clear_has_linear_constraint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::LinearConstraint* linear_constraint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static Constraint* default_instance_;
};
// -------------------------------------------------------------------

class LinearConstraint : public ::google::protobuf::Message {
 public:
  LinearConstraint();
  virtual ~LinearConstraint();

  LinearConstraint(const LinearConstraint& from);

  inline LinearConstraint& operator=(const LinearConstraint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearConstraint& default_instance();

  void Swap(LinearConstraint* other);

  // implements Message ----------------------------------------------

  LinearConstraint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinearConstraint& from);
  void MergeFrom(const LinearConstraint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LinearConstraint_ConstraintSemantics ConstraintSemantics;
  static const ConstraintSemantics GENERAL = LinearConstraint_ConstraintSemantics_GENERAL;
  static const ConstraintSemantics SYMM_GROUND = LinearConstraint_ConstraintSemantics_SYMM_GROUND;
  static const ConstraintSemantics SYMM_LEGW = LinearConstraint_ConstraintSemantics_SYMM_LEGW;
  static const ConstraintSemantics SYMM_LEGL = LinearConstraint_ConstraintSemantics_SYMM_LEGL;
  static const ConstraintSemantics SYMM_SPACING = LinearConstraint_ConstraintSemantics_SYMM_SPACING;
  static inline bool ConstraintSemantics_IsValid(int value) {
    return LinearConstraint_ConstraintSemantics_IsValid(value);
  }
  static const ConstraintSemantics ConstraintSemantics_MIN =
    LinearConstraint_ConstraintSemantics_ConstraintSemantics_MIN;
  static const ConstraintSemantics ConstraintSemantics_MAX =
    LinearConstraint_ConstraintSemantics_ConstraintSemantics_MAX;
  static const int ConstraintSemantics_ARRAYSIZE =
    LinearConstraint_ConstraintSemantics_ConstraintSemantics_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ConstraintSemantics_descriptor() {
    return LinearConstraint_ConstraintSemantics_descriptor();
  }
  static inline const ::std::string& ConstraintSemantics_Name(ConstraintSemantics value) {
    return LinearConstraint_ConstraintSemantics_Name(value);
  }
  static inline bool ConstraintSemantics_Parse(const ::std::string& name,
      ConstraintSemantics* value) {
    return LinearConstraint_ConstraintSemantics_Parse(name, value);
  }

  typedef LinearConstraint_Type Type;
  static const Type EQUALITY = LinearConstraint_Type_EQUALITY;
  static const Type LESS_THAN_ZERO = LinearConstraint_Type_LESS_THAN_ZERO;
  static inline bool Type_IsValid(int value) {
    return LinearConstraint_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LinearConstraint_Type_Type_MIN;
  static const Type Type_MAX =
    LinearConstraint_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LinearConstraint_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return LinearConstraint_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return LinearConstraint_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return LinearConstraint_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .FabByExample.proto.symbolic.LinearExpr expr = 1;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::LinearExpr& expr() const;
  inline ::FabByExample::proto::symbolic::LinearExpr* mutable_expr();
  inline ::FabByExample::proto::symbolic::LinearExpr* release_expr();
  inline void set_allocated_expr(::FabByExample::proto::symbolic::LinearExpr* expr);

  // optional .FabByExample.proto.LinearConstraint.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::FabByExample::proto::LinearConstraint_Type type() const;
  inline void set_type(::FabByExample::proto::LinearConstraint_Type value);

  // optional .FabByExample.proto.LinearConstraint.ConstraintSemantics constraintSemantics = 3;
  inline bool has_constraintsemantics() const;
  inline void clear_constraintsemantics();
  static const int kConstraintSemanticsFieldNumber = 3;
  inline ::FabByExample::proto::LinearConstraint_ConstraintSemantics constraintsemantics() const;
  inline void set_constraintsemantics(::FabByExample::proto::LinearConstraint_ConstraintSemantics value);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.LinearConstraint)
 private:
  inline void set_has_expr();
  inline void clear_has_expr();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_constraintsemantics();
  inline void clear_has_constraintsemantics();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FabByExample::proto::symbolic::LinearExpr* expr_;
  int type_;
  int constraintsemantics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static LinearConstraint* default_instance_;
};
// -------------------------------------------------------------------

class Articulation : public ::google::protobuf::Message {
 public:
  Articulation();
  virtual ~Articulation();

  Articulation(const Articulation& from);

  inline Articulation& operator=(const Articulation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Articulation& default_instance();

  void Swap(Articulation* other);

  // implements Message ----------------------------------------------

  Articulation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Articulation& from);
  void MergeFrom(const Articulation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FabByExample.proto.symbolic.Transform transforms = 1;
  inline int transforms_size() const;
  inline void clear_transforms();
  static const int kTransformsFieldNumber = 1;
  inline const ::FabByExample::proto::symbolic::Transform& transforms(int index) const;
  inline ::FabByExample::proto::symbolic::Transform* mutable_transforms(int index);
  inline ::FabByExample::proto::symbolic::Transform* add_transforms();
  inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Transform >&
      transforms() const;
  inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Transform >*
      mutable_transforms();

  // optional .FabByExample.proto.symbolic.Point3S center = 2;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 2;
  inline const ::FabByExample::proto::symbolic::Point3S& center() const;
  inline ::FabByExample::proto::symbolic::Point3S* mutable_center();
  inline ::FabByExample::proto::symbolic::Point3S* release_center();
  inline void set_allocated_center(::FabByExample::proto::symbolic::Point3S* center);

  // @@protoc_insertion_point(class_scope:FabByExample.proto.Articulation)
 private:
  inline void set_has_center();
  inline void clear_has_center();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Transform > transforms_;
  ::FabByExample::proto::symbolic::Point3S* center_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_template_2eproto();
  friend void protobuf_AssignDesc_template_2eproto();
  friend void protobuf_ShutdownFile_template_2eproto();

  void InitAsDefaultInstance();
  static Articulation* default_instance_;
};
// ===================================================================


// ===================================================================

// TemplateSet

// repeated .FabByExample.proto.Template template = 1;
inline int TemplateSet::template__size() const {
  return template__.size();
}
inline void TemplateSet::clear_template_() {
  template__.Clear();
}
inline const ::FabByExample::proto::Template& TemplateSet::template_(int index) const {
  return template__.Get(index);
}
inline ::FabByExample::proto::Template* TemplateSet::mutable_template_(int index) {
  return template__.Mutable(index);
}
inline ::FabByExample::proto::Template* TemplateSet::add_template_() {
  return template__.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Template >&
TemplateSet::template_() const {
  return template__;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Template >*
TemplateSet::mutable_template_() {
  return &template__;
}

// optional int32 root_template_id = 2;
inline bool TemplateSet::has_root_template_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TemplateSet::set_has_root_template_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TemplateSet::clear_has_root_template_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TemplateSet::clear_root_template_id() {
  root_template_id_ = 0;
  clear_has_root_template_id();
}
inline ::google::protobuf::int32 TemplateSet::root_template_id() const {
  return root_template_id_;
}
inline void TemplateSet::set_root_template_id(::google::protobuf::int32 value) {
  set_has_root_template_id();
  root_template_id_ = value;
}

// optional .FabByExample.proto.GaitInformation gaitInfo = 3;
inline bool TemplateSet::has_gaitinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TemplateSet::set_has_gaitinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TemplateSet::clear_has_gaitinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TemplateSet::clear_gaitinfo() {
  if (gaitinfo_ != NULL) gaitinfo_->::FabByExample::proto::GaitInformation::Clear();
  clear_has_gaitinfo();
}
inline const ::FabByExample::proto::GaitInformation& TemplateSet::gaitinfo() const {
  return gaitinfo_ != NULL ? *gaitinfo_ : *default_instance_->gaitinfo_;
}
inline ::FabByExample::proto::GaitInformation* TemplateSet::mutable_gaitinfo() {
  set_has_gaitinfo();
  if (gaitinfo_ == NULL) gaitinfo_ = new ::FabByExample::proto::GaitInformation;
  return gaitinfo_;
}
inline ::FabByExample::proto::GaitInformation* TemplateSet::release_gaitinfo() {
  clear_has_gaitinfo();
  ::FabByExample::proto::GaitInformation* temp = gaitinfo_;
  gaitinfo_ = NULL;
  return temp;
}
inline void TemplateSet::set_allocated_gaitinfo(::FabByExample::proto::GaitInformation* gaitinfo) {
  delete gaitinfo_;
  gaitinfo_ = gaitinfo;
  if (gaitinfo) {
    set_has_gaitinfo();
  } else {
    clear_has_gaitinfo();
  }
}

// -------------------------------------------------------------------

// GaitInformation

// repeated .FabByExample.proto.SavedGait savedGaits = 1;
inline int GaitInformation::savedgaits_size() const {
  return savedgaits_.size();
}
inline void GaitInformation::clear_savedgaits() {
  savedgaits_.Clear();
}
inline const ::FabByExample::proto::SavedGait& GaitInformation::savedgaits(int index) const {
  return savedgaits_.Get(index);
}
inline ::FabByExample::proto::SavedGait* GaitInformation::mutable_savedgaits(int index) {
  return savedgaits_.Mutable(index);
}
inline ::FabByExample::proto::SavedGait* GaitInformation::add_savedgaits() {
  return savedgaits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::SavedGait >&
GaitInformation::savedgaits() const {
  return savedgaits_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::SavedGait >*
GaitInformation::mutable_savedgaits() {
  return &savedgaits_;
}

// repeated int32 gaitSequence = 2;
inline int GaitInformation::gaitsequence_size() const {
  return gaitsequence_.size();
}
inline void GaitInformation::clear_gaitsequence() {
  gaitsequence_.Clear();
}
inline ::google::protobuf::int32 GaitInformation::gaitsequence(int index) const {
  return gaitsequence_.Get(index);
}
inline void GaitInformation::set_gaitsequence(int index, ::google::protobuf::int32 value) {
  gaitsequence_.Set(index, value);
}
inline void GaitInformation::add_gaitsequence(::google::protobuf::int32 value) {
  gaitsequence_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GaitInformation::gaitsequence() const {
  return gaitsequence_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GaitInformation::mutable_gaitsequence() {
  return &gaitsequence_;
}

// -------------------------------------------------------------------

// SavedGait

// optional string name = 1;
inline bool SavedGait::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SavedGait::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SavedGait::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SavedGait::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SavedGait::name() const {
  return *name_;
}
inline void SavedGait::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SavedGait::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SavedGait::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SavedGait::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SavedGait::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SavedGait::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional double desiredDirection = 2;
inline bool SavedGait::has_desireddirection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SavedGait::set_has_desireddirection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SavedGait::clear_has_desireddirection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SavedGait::clear_desireddirection() {
  desireddirection_ = 0;
  clear_has_desireddirection();
}
inline double SavedGait::desireddirection() const {
  return desireddirection_;
}
inline void SavedGait::set_desireddirection(double value) {
  set_has_desireddirection();
  desireddirection_ = value;
}

// repeated int32 jointInfo_id = 3;
inline int SavedGait::jointinfo_id_size() const {
  return jointinfo_id_.size();
}
inline void SavedGait::clear_jointinfo_id() {
  jointinfo_id_.Clear();
}
inline ::google::protobuf::int32 SavedGait::jointinfo_id(int index) const {
  return jointinfo_id_.Get(index);
}
inline void SavedGait::set_jointinfo_id(int index, ::google::protobuf::int32 value) {
  jointinfo_id_.Set(index, value);
}
inline void SavedGait::add_jointinfo_id(::google::protobuf::int32 value) {
  jointinfo_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SavedGait::jointinfo_id() const {
  return jointinfo_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SavedGait::mutable_jointinfo_id() {
  return &jointinfo_id_;
}

// repeated double jointInfo_angle = 4;
inline int SavedGait::jointinfo_angle_size() const {
  return jointinfo_angle_.size();
}
inline void SavedGait::clear_jointinfo_angle() {
  jointinfo_angle_.Clear();
}
inline double SavedGait::jointinfo_angle(int index) const {
  return jointinfo_angle_.Get(index);
}
inline void SavedGait::set_jointinfo_angle(int index, double value) {
  jointinfo_angle_.Set(index, value);
}
inline void SavedGait::add_jointinfo_angle(double value) {
  jointinfo_angle_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
SavedGait::jointinfo_angle() const {
  return jointinfo_angle_;
}
inline ::google::protobuf::RepeatedField< double >*
SavedGait::mutable_jointinfo_angle() {
  return &jointinfo_angle_;
}

// -------------------------------------------------------------------

// Template

// optional int32 id = 1;
inline bool Template::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Template::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Template::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Template::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Template::id() const {
  return id_;
}
inline void Template::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Template::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Template::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Template::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Template::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Template::name() const {
  return *name_;
}
inline void Template::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Template::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Template::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Template::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Template::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Template::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .FabByExample.proto.symbolic.Parameter parameter = 3;
inline int Template::parameter_size() const {
  return parameter_.size();
}
inline void Template::clear_parameter() {
  parameter_.Clear();
}
inline const ::FabByExample::proto::symbolic::Parameter& Template::parameter(int index) const {
  return parameter_.Get(index);
}
inline ::FabByExample::proto::symbolic::Parameter* Template::mutable_parameter(int index) {
  return parameter_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::Parameter* Template::add_parameter() {
  return parameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Parameter >&
Template::parameter() const {
  return parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Parameter >*
Template::mutable_parameter() {
  return &parameter_;
}

// optional .FabByExample.proto.MappingFunction mapping_function = 4;
inline bool Template::has_mapping_function() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Template::set_has_mapping_function() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Template::clear_has_mapping_function() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Template::clear_mapping_function() {
  if (mapping_function_ != NULL) mapping_function_->::FabByExample::proto::MappingFunction::Clear();
  clear_has_mapping_function();
}
inline const ::FabByExample::proto::MappingFunction& Template::mapping_function() const {
  return mapping_function_ != NULL ? *mapping_function_ : *default_instance_->mapping_function_;
}
inline ::FabByExample::proto::MappingFunction* Template::mutable_mapping_function() {
  set_has_mapping_function();
  if (mapping_function_ == NULL) mapping_function_ = new ::FabByExample::proto::MappingFunction;
  return mapping_function_;
}
inline ::FabByExample::proto::MappingFunction* Template::release_mapping_function() {
  clear_has_mapping_function();
  ::FabByExample::proto::MappingFunction* temp = mapping_function_;
  mapping_function_ = NULL;
  return temp;
}
inline void Template::set_allocated_mapping_function(::FabByExample::proto::MappingFunction* mapping_function) {
  delete mapping_function_;
  mapping_function_ = mapping_function;
  if (mapping_function) {
    set_has_mapping_function();
  } else {
    clear_has_mapping_function();
  }
}

// optional .FabByExample.proto.FeasibleSet feasible_set = 5;
inline bool Template::has_feasible_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Template::set_has_feasible_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Template::clear_has_feasible_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Template::clear_feasible_set() {
  if (feasible_set_ != NULL) feasible_set_->::FabByExample::proto::FeasibleSet::Clear();
  clear_has_feasible_set();
}
inline const ::FabByExample::proto::FeasibleSet& Template::feasible_set() const {
  return feasible_set_ != NULL ? *feasible_set_ : *default_instance_->feasible_set_;
}
inline ::FabByExample::proto::FeasibleSet* Template::mutable_feasible_set() {
  set_has_feasible_set();
  if (feasible_set_ == NULL) feasible_set_ = new ::FabByExample::proto::FeasibleSet;
  return feasible_set_;
}
inline ::FabByExample::proto::FeasibleSet* Template::release_feasible_set() {
  clear_has_feasible_set();
  ::FabByExample::proto::FeasibleSet* temp = feasible_set_;
  feasible_set_ = NULL;
  return temp;
}
inline void Template::set_allocated_feasible_set(::FabByExample::proto::FeasibleSet* feasible_set) {
  delete feasible_set_;
  feasible_set_ = feasible_set;
  if (feasible_set) {
    set_has_feasible_set();
  } else {
    clear_has_feasible_set();
  }
}

// repeated int32 child_template_id = 6;
inline int Template::child_template_id_size() const {
  return child_template_id_.size();
}
inline void Template::clear_child_template_id() {
  child_template_id_.Clear();
}
inline ::google::protobuf::int32 Template::child_template_id(int index) const {
  return child_template_id_.Get(index);
}
inline void Template::set_child_template_id(int index, ::google::protobuf::int32 value) {
  child_template_id_.Set(index, value);
}
inline void Template::add_child_template_id(::google::protobuf::int32 value) {
  child_template_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Template::child_template_id() const {
  return child_template_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Template::mutable_child_template_id() {
  return &child_template_id_;
}

// repeated .FabByExample.proto.Connection connection = 7;
inline int Template::connection_size() const {
  return connection_.size();
}
inline void Template::clear_connection() {
  connection_.Clear();
}
inline const ::FabByExample::proto::Connection& Template::connection(int index) const {
  return connection_.Get(index);
}
inline ::FabByExample::proto::Connection* Template::mutable_connection(int index) {
  return connection_.Mutable(index);
}
inline ::FabByExample::proto::Connection* Template::add_connection() {
  return connection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Connection >&
Template::connection() const {
  return connection_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Connection >*
Template::mutable_connection() {
  return &connection_;
}

// repeated .FabByExample.proto.Patch patch = 8;
inline int Template::patch_size() const {
  return patch_.size();
}
inline void Template::clear_patch() {
  patch_.Clear();
}
inline const ::FabByExample::proto::Patch& Template::patch(int index) const {
  return patch_.Get(index);
}
inline ::FabByExample::proto::Patch* Template::mutable_patch(int index) {
  return patch_.Mutable(index);
}
inline ::FabByExample::proto::Patch* Template::add_patch() {
  return patch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Patch >&
Template::patch() const {
  return patch_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Patch >*
Template::mutable_patch() {
  return &patch_;
}

// optional bool independent = 9;
inline bool Template::has_independent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Template::set_has_independent() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Template::clear_has_independent() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Template::clear_independent() {
  independent_ = false;
  clear_has_independent();
}
inline bool Template::independent() const {
  return independent_;
}
inline void Template::set_independent(bool value) {
  set_has_independent();
  independent_ = value;
}

// optional .FabByExample.proto.Semantics semantics = 10;
inline bool Template::has_semantics() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Template::set_has_semantics() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Template::clear_has_semantics() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Template::clear_semantics() {
  if (semantics_ != NULL) semantics_->::FabByExample::proto::Semantics::Clear();
  clear_has_semantics();
}
inline const ::FabByExample::proto::Semantics& Template::semantics() const {
  return semantics_ != NULL ? *semantics_ : *default_instance_->semantics_;
}
inline ::FabByExample::proto::Semantics* Template::mutable_semantics() {
  set_has_semantics();
  if (semantics_ == NULL) semantics_ = new ::FabByExample::proto::Semantics;
  return semantics_;
}
inline ::FabByExample::proto::Semantics* Template::release_semantics() {
  clear_has_semantics();
  ::FabByExample::proto::Semantics* temp = semantics_;
  semantics_ = NULL;
  return temp;
}
inline void Template::set_allocated_semantics(::FabByExample::proto::Semantics* semantics) {
  delete semantics_;
  semantics_ = semantics;
  if (semantics) {
    set_has_semantics();
  } else {
    clear_has_semantics();
  }
}

// repeated .FabByExample.proto.symbolic.Point3S contactPoints = 11;
inline int Template::contactpoints_size() const {
  return contactpoints_.size();
}
inline void Template::clear_contactpoints() {
  contactpoints_.Clear();
}
inline const ::FabByExample::proto::symbolic::Point3S& Template::contactpoints(int index) const {
  return contactpoints_.Get(index);
}
inline ::FabByExample::proto::symbolic::Point3S* Template::mutable_contactpoints(int index) {
  return contactpoints_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::Point3S* Template::add_contactpoints() {
  return contactpoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Point3S >&
Template::contactpoints() const {
  return contactpoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Point3S >*
Template::mutable_contactpoints() {
  return &contactpoints_;
}

// repeated .FabByExample.proto.ContactInfo contactInfo = 12;
inline int Template::contactinfo_size() const {
  return contactinfo_.size();
}
inline void Template::clear_contactinfo() {
  contactinfo_.Clear();
}
inline const ::FabByExample::proto::ContactInfo& Template::contactinfo(int index) const {
  return contactinfo_.Get(index);
}
inline ::FabByExample::proto::ContactInfo* Template::mutable_contactinfo(int index) {
  return contactinfo_.Mutable(index);
}
inline ::FabByExample::proto::ContactInfo* Template::add_contactinfo() {
  return contactinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::ContactInfo >&
Template::contactinfo() const {
  return contactinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::ContactInfo >*
Template::mutable_contactinfo() {
  return &contactinfo_;
}

// optional .FabByExample.proto.SymmetryChoices symmetryChoices = 13;
inline bool Template::has_symmetrychoices() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Template::set_has_symmetrychoices() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Template::clear_has_symmetrychoices() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Template::clear_symmetrychoices() {
  if (symmetrychoices_ != NULL) symmetrychoices_->::FabByExample::proto::SymmetryChoices::Clear();
  clear_has_symmetrychoices();
}
inline const ::FabByExample::proto::SymmetryChoices& Template::symmetrychoices() const {
  return symmetrychoices_ != NULL ? *symmetrychoices_ : *default_instance_->symmetrychoices_;
}
inline ::FabByExample::proto::SymmetryChoices* Template::mutable_symmetrychoices() {
  set_has_symmetrychoices();
  if (symmetrychoices_ == NULL) symmetrychoices_ = new ::FabByExample::proto::SymmetryChoices;
  return symmetrychoices_;
}
inline ::FabByExample::proto::SymmetryChoices* Template::release_symmetrychoices() {
  clear_has_symmetrychoices();
  ::FabByExample::proto::SymmetryChoices* temp = symmetrychoices_;
  symmetrychoices_ = NULL;
  return temp;
}
inline void Template::set_allocated_symmetrychoices(::FabByExample::proto::SymmetryChoices* symmetrychoices) {
  delete symmetrychoices_;
  symmetrychoices_ = symmetrychoices;
  if (symmetrychoices) {
    set_has_symmetrychoices();
  } else {
    clear_has_symmetrychoices();
  }
}

// -------------------------------------------------------------------

// ContactInfo

// optional .FabByExample.proto.symbolic.Point3S point = 1;
inline bool ContactInfo::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactInfo::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactInfo::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactInfo::clear_point() {
  if (point_ != NULL) point_->::FabByExample::proto::symbolic::Point3S::Clear();
  clear_has_point();
}
inline const ::FabByExample::proto::symbolic::Point3S& ContactInfo::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::FabByExample::proto::symbolic::Point3S* ContactInfo::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::FabByExample::proto::symbolic::Point3S;
  return point_;
}
inline ::FabByExample::proto::symbolic::Point3S* ContactInfo::release_point() {
  clear_has_point();
  ::FabByExample::proto::symbolic::Point3S* temp = point_;
  point_ = NULL;
  return temp;
}
inline void ContactInfo::set_allocated_point(::FabByExample::proto::symbolic::Point3S* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// optional bool hasBeenConstraint = 2;
inline bool ContactInfo::has_hasbeenconstraint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactInfo::set_has_hasbeenconstraint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactInfo::clear_has_hasbeenconstraint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactInfo::clear_hasbeenconstraint() {
  hasbeenconstraint_ = false;
  clear_has_hasbeenconstraint();
}
inline bool ContactInfo::hasbeenconstraint() const {
  return hasbeenconstraint_;
}
inline void ContactInfo::set_hasbeenconstraint(bool value) {
  set_has_hasbeenconstraint();
  hasbeenconstraint_ = value;
}

// -------------------------------------------------------------------

// SymmetryChoices

// optional bool symm_ground = 1;
inline bool SymmetryChoices::has_symm_ground() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymmetryChoices::set_has_symm_ground() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymmetryChoices::clear_has_symm_ground() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymmetryChoices::clear_symm_ground() {
  symm_ground_ = false;
  clear_has_symm_ground();
}
inline bool SymmetryChoices::symm_ground() const {
  return symm_ground_;
}
inline void SymmetryChoices::set_symm_ground(bool value) {
  set_has_symm_ground();
  symm_ground_ = value;
}

// optional bool symm_legW = 2;
inline bool SymmetryChoices::has_symm_legw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymmetryChoices::set_has_symm_legw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymmetryChoices::clear_has_symm_legw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymmetryChoices::clear_symm_legw() {
  symm_legw_ = false;
  clear_has_symm_legw();
}
inline bool SymmetryChoices::symm_legw() const {
  return symm_legw_;
}
inline void SymmetryChoices::set_symm_legw(bool value) {
  set_has_symm_legw();
  symm_legw_ = value;
}

// optional bool symm_legL = 3;
inline bool SymmetryChoices::has_symm_legl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymmetryChoices::set_has_symm_legl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymmetryChoices::clear_has_symm_legl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymmetryChoices::clear_symm_legl() {
  symm_legl_ = false;
  clear_has_symm_legl();
}
inline bool SymmetryChoices::symm_legl() const {
  return symm_legl_;
}
inline void SymmetryChoices::set_symm_legl(bool value) {
  set_has_symm_legl();
  symm_legl_ = value;
}

// optional bool symm_spacing = 4;
inline bool SymmetryChoices::has_symm_spacing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymmetryChoices::set_has_symm_spacing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymmetryChoices::clear_has_symm_spacing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymmetryChoices::clear_symm_spacing() {
  symm_spacing_ = false;
  clear_has_symm_spacing();
}
inline bool SymmetryChoices::symm_spacing() const {
  return symm_spacing_;
}
inline void SymmetryChoices::set_symm_spacing(bool value) {
  set_has_symm_spacing();
  symm_spacing_ = value;
}

// -------------------------------------------------------------------

// Semantics

// optional .FabByExample.proto.Semantics.PrintMethod printMethod = 1;
inline bool Semantics::has_printmethod() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Semantics::set_has_printmethod() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Semantics::clear_has_printmethod() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Semantics::clear_printmethod() {
  printmethod_ = 1;
  clear_has_printmethod();
}
inline ::FabByExample::proto::Semantics_PrintMethod Semantics::printmethod() const {
  return static_cast< ::FabByExample::proto::Semantics_PrintMethod >(printmethod_);
}
inline void Semantics::set_printmethod(::FabByExample::proto::Semantics_PrintMethod value) {
  assert(::FabByExample::proto::Semantics_PrintMethod_IsValid(value));
  set_has_printmethod();
  printmethod_ = value;
}

// optional .FabByExample.proto.Semantics.PartType partType = 2;
inline bool Semantics::has_parttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Semantics::set_has_parttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Semantics::clear_has_parttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Semantics::clear_parttype() {
  parttype_ = 1;
  clear_has_parttype();
}
inline ::FabByExample::proto::Semantics_PartType Semantics::parttype() const {
  return static_cast< ::FabByExample::proto::Semantics_PartType >(parttype_);
}
inline void Semantics::set_parttype(::FabByExample::proto::Semantics_PartType value) {
  assert(::FabByExample::proto::Semantics_PartType_IsValid(value));
  set_has_parttype();
  parttype_ = value;
}

// -------------------------------------------------------------------

// Patch

// optional int32 id = 1;
inline bool Patch::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Patch::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Patch::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Patch::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Patch::id() const {
  return id_;
}
inline void Patch::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .FabByExample.proto.Edge2SPatch edge2SPatch = 2;
inline bool Patch::has_edge2spatch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Patch::set_has_edge2spatch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Patch::clear_has_edge2spatch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Patch::clear_edge2spatch() {
  if (edge2spatch_ != NULL) edge2spatch_->::FabByExample::proto::Edge2SPatch::Clear();
  clear_has_edge2spatch();
}
inline const ::FabByExample::proto::Edge2SPatch& Patch::edge2spatch() const {
  return edge2spatch_ != NULL ? *edge2spatch_ : *default_instance_->edge2spatch_;
}
inline ::FabByExample::proto::Edge2SPatch* Patch::mutable_edge2spatch() {
  set_has_edge2spatch();
  if (edge2spatch_ == NULL) edge2spatch_ = new ::FabByExample::proto::Edge2SPatch;
  return edge2spatch_;
}
inline ::FabByExample::proto::Edge2SPatch* Patch::release_edge2spatch() {
  clear_has_edge2spatch();
  ::FabByExample::proto::Edge2SPatch* temp = edge2spatch_;
  edge2spatch_ = NULL;
  return temp;
}
inline void Patch::set_allocated_edge2spatch(::FabByExample::proto::Edge2SPatch* edge2spatch) {
  delete edge2spatch_;
  edge2spatch_ = edge2spatch;
  if (edge2spatch) {
    set_has_edge2spatch();
  } else {
    clear_has_edge2spatch();
  }
}

// optional .FabByExample.proto.ServoPointPatch servoPointPatch = 3;
inline bool Patch::has_servopointpatch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Patch::set_has_servopointpatch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Patch::clear_has_servopointpatch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Patch::clear_servopointpatch() {
  if (servopointpatch_ != NULL) servopointpatch_->::FabByExample::proto::ServoPointPatch::Clear();
  clear_has_servopointpatch();
}
inline const ::FabByExample::proto::ServoPointPatch& Patch::servopointpatch() const {
  return servopointpatch_ != NULL ? *servopointpatch_ : *default_instance_->servopointpatch_;
}
inline ::FabByExample::proto::ServoPointPatch* Patch::mutable_servopointpatch() {
  set_has_servopointpatch();
  if (servopointpatch_ == NULL) servopointpatch_ = new ::FabByExample::proto::ServoPointPatch;
  return servopointpatch_;
}
inline ::FabByExample::proto::ServoPointPatch* Patch::release_servopointpatch() {
  clear_has_servopointpatch();
  ::FabByExample::proto::ServoPointPatch* temp = servopointpatch_;
  servopointpatch_ = NULL;
  return temp;
}
inline void Patch::set_allocated_servopointpatch(::FabByExample::proto::ServoPointPatch* servopointpatch) {
  delete servopointpatch_;
  servopointpatch_ = servopointpatch;
  if (servopointpatch) {
    set_has_servopointpatch();
  } else {
    clear_has_servopointpatch();
  }
}

// optional .FabByExample.proto.ServoLinePatch servoLinePatch = 4;
inline bool Patch::has_servolinepatch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Patch::set_has_servolinepatch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Patch::clear_has_servolinepatch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Patch::clear_servolinepatch() {
  if (servolinepatch_ != NULL) servolinepatch_->::FabByExample::proto::ServoLinePatch::Clear();
  clear_has_servolinepatch();
}
inline const ::FabByExample::proto::ServoLinePatch& Patch::servolinepatch() const {
  return servolinepatch_ != NULL ? *servolinepatch_ : *default_instance_->servolinepatch_;
}
inline ::FabByExample::proto::ServoLinePatch* Patch::mutable_servolinepatch() {
  set_has_servolinepatch();
  if (servolinepatch_ == NULL) servolinepatch_ = new ::FabByExample::proto::ServoLinePatch;
  return servolinepatch_;
}
inline ::FabByExample::proto::ServoLinePatch* Patch::release_servolinepatch() {
  clear_has_servolinepatch();
  ::FabByExample::proto::ServoLinePatch* temp = servolinepatch_;
  servolinepatch_ = NULL;
  return temp;
}
inline void Patch::set_allocated_servolinepatch(::FabByExample::proto::ServoLinePatch* servolinepatch) {
  delete servolinepatch_;
  servolinepatch_ = servolinepatch;
  if (servolinepatch) {
    set_has_servolinepatch();
  } else {
    clear_has_servolinepatch();
  }
}

// optional .FabByExample.proto.PeripheralPatch peripheralpatch = 5;
inline bool Patch::has_peripheralpatch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Patch::set_has_peripheralpatch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Patch::clear_has_peripheralpatch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Patch::clear_peripheralpatch() {
  if (peripheralpatch_ != NULL) peripheralpatch_->::FabByExample::proto::PeripheralPatch::Clear();
  clear_has_peripheralpatch();
}
inline const ::FabByExample::proto::PeripheralPatch& Patch::peripheralpatch() const {
  return peripheralpatch_ != NULL ? *peripheralpatch_ : *default_instance_->peripheralpatch_;
}
inline ::FabByExample::proto::PeripheralPatch* Patch::mutable_peripheralpatch() {
  set_has_peripheralpatch();
  if (peripheralpatch_ == NULL) peripheralpatch_ = new ::FabByExample::proto::PeripheralPatch;
  return peripheralpatch_;
}
inline ::FabByExample::proto::PeripheralPatch* Patch::release_peripheralpatch() {
  clear_has_peripheralpatch();
  ::FabByExample::proto::PeripheralPatch* temp = peripheralpatch_;
  peripheralpatch_ = NULL;
  return temp;
}
inline void Patch::set_allocated_peripheralpatch(::FabByExample::proto::PeripheralPatch* peripheralpatch) {
  delete peripheralpatch_;
  peripheralpatch_ = peripheralpatch;
  if (peripheralpatch) {
    set_has_peripheralpatch();
  } else {
    clear_has_peripheralpatch();
  }
}

// -------------------------------------------------------------------

// ServoPointPatch

// optional .FabByExample.proto.symbolic.Point3S center = 1;
inline bool ServoPointPatch::has_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServoPointPatch::set_has_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServoPointPatch::clear_has_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServoPointPatch::clear_center() {
  if (center_ != NULL) center_->::FabByExample::proto::symbolic::Point3S::Clear();
  clear_has_center();
}
inline const ::FabByExample::proto::symbolic::Point3S& ServoPointPatch::center() const {
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::FabByExample::proto::symbolic::Point3S* ServoPointPatch::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::FabByExample::proto::symbolic::Point3S;
  return center_;
}
inline ::FabByExample::proto::symbolic::Point3S* ServoPointPatch::release_center() {
  clear_has_center();
  ::FabByExample::proto::symbolic::Point3S* temp = center_;
  center_ = NULL;
  return temp;
}
inline void ServoPointPatch::set_allocated_center(::FabByExample::proto::symbolic::Point3S* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
}

// repeated double normal = 2;
inline int ServoPointPatch::normal_size() const {
  return normal_.size();
}
inline void ServoPointPatch::clear_normal() {
  normal_.Clear();
}
inline double ServoPointPatch::normal(int index) const {
  return normal_.Get(index);
}
inline void ServoPointPatch::set_normal(int index, double value) {
  normal_.Set(index, value);
}
inline void ServoPointPatch::add_normal(double value) {
  normal_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
ServoPointPatch::normal() const {
  return normal_;
}
inline ::google::protobuf::RepeatedField< double >*
ServoPointPatch::mutable_normal() {
  return &normal_;
}

// optional .FabByExample.proto.symbolic.LinearExpr separation = 3;
inline bool ServoPointPatch::has_separation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServoPointPatch::set_has_separation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServoPointPatch::clear_has_separation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServoPointPatch::clear_separation() {
  if (separation_ != NULL) separation_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_separation();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& ServoPointPatch::separation() const {
  return separation_ != NULL ? *separation_ : *default_instance_->separation_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* ServoPointPatch::mutable_separation() {
  set_has_separation();
  if (separation_ == NULL) separation_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return separation_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* ServoPointPatch::release_separation() {
  clear_has_separation();
  ::FabByExample::proto::symbolic::LinearExpr* temp = separation_;
  separation_ = NULL;
  return temp;
}
inline void ServoPointPatch::set_allocated_separation(::FabByExample::proto::symbolic::LinearExpr* separation) {
  delete separation_;
  separation_ = separation;
  if (separation) {
    set_has_separation();
  } else {
    clear_has_separation();
  }
}

// -------------------------------------------------------------------

// ServoSpacingInfo

// optional .FabByExample.proto.symbolic.LinearExpr alpha = 1;
inline bool ServoSpacingInfo::has_alpha() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServoSpacingInfo::set_has_alpha() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServoSpacingInfo::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServoSpacingInfo::clear_alpha() {
  if (alpha_ != NULL) alpha_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_alpha();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& ServoSpacingInfo::alpha() const {
  return alpha_ != NULL ? *alpha_ : *default_instance_->alpha_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* ServoSpacingInfo::mutable_alpha() {
  set_has_alpha();
  if (alpha_ == NULL) alpha_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return alpha_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* ServoSpacingInfo::release_alpha() {
  clear_has_alpha();
  ::FabByExample::proto::symbolic::LinearExpr* temp = alpha_;
  alpha_ = NULL;
  return temp;
}
inline void ServoSpacingInfo::set_allocated_alpha(::FabByExample::proto::symbolic::LinearExpr* alpha) {
  delete alpha_;
  alpha_ = alpha;
  if (alpha) {
    set_has_alpha();
  } else {
    clear_has_alpha();
  }
}

// optional .FabByExample.proto.symbolic.LinearExpr separation_h = 2;
inline bool ServoSpacingInfo::has_separation_h() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServoSpacingInfo::set_has_separation_h() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServoSpacingInfo::clear_has_separation_h() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServoSpacingInfo::clear_separation_h() {
  if (separation_h_ != NULL) separation_h_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_separation_h();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& ServoSpacingInfo::separation_h() const {
  return separation_h_ != NULL ? *separation_h_ : *default_instance_->separation_h_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* ServoSpacingInfo::mutable_separation_h() {
  set_has_separation_h();
  if (separation_h_ == NULL) separation_h_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return separation_h_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* ServoSpacingInfo::release_separation_h() {
  clear_has_separation_h();
  ::FabByExample::proto::symbolic::LinearExpr* temp = separation_h_;
  separation_h_ = NULL;
  return temp;
}
inline void ServoSpacingInfo::set_allocated_separation_h(::FabByExample::proto::symbolic::LinearExpr* separation_h) {
  delete separation_h_;
  separation_h_ = separation_h;
  if (separation_h) {
    set_has_separation_h();
  } else {
    clear_has_separation_h();
  }
}

// repeated .FabByExample.proto.symbolic.LinearExpr separation_w = 3;
inline int ServoSpacingInfo::separation_w_size() const {
  return separation_w_.size();
}
inline void ServoSpacingInfo::clear_separation_w() {
  separation_w_.Clear();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& ServoSpacingInfo::separation_w(int index) const {
  return separation_w_.Get(index);
}
inline ::FabByExample::proto::symbolic::LinearExpr* ServoSpacingInfo::mutable_separation_w(int index) {
  return separation_w_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::LinearExpr* ServoSpacingInfo::add_separation_w() {
  return separation_w_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >&
ServoSpacingInfo::separation_w() const {
  return separation_w_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::LinearExpr >*
ServoSpacingInfo::mutable_separation_w() {
  return &separation_w_;
}

// repeated int32 associatedTemplates = 4;
inline int ServoSpacingInfo::associatedtemplates_size() const {
  return associatedtemplates_.size();
}
inline void ServoSpacingInfo::clear_associatedtemplates() {
  associatedtemplates_.Clear();
}
inline ::google::protobuf::int32 ServoSpacingInfo::associatedtemplates(int index) const {
  return associatedtemplates_.Get(index);
}
inline void ServoSpacingInfo::set_associatedtemplates(int index, ::google::protobuf::int32 value) {
  associatedtemplates_.Set(index, value);
}
inline void ServoSpacingInfo::add_associatedtemplates(::google::protobuf::int32 value) {
  associatedtemplates_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ServoSpacingInfo::associatedtemplates() const {
  return associatedtemplates_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ServoSpacingInfo::mutable_associatedtemplates() {
  return &associatedtemplates_;
}

// -------------------------------------------------------------------

// ServoLinePatch

// optional .FabByExample.proto.symbolic.Point3S startPoint = 1;
inline bool ServoLinePatch::has_startpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServoLinePatch::set_has_startpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServoLinePatch::clear_has_startpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServoLinePatch::clear_startpoint() {
  if (startpoint_ != NULL) startpoint_->::FabByExample::proto::symbolic::Point3S::Clear();
  clear_has_startpoint();
}
inline const ::FabByExample::proto::symbolic::Point3S& ServoLinePatch::startpoint() const {
  return startpoint_ != NULL ? *startpoint_ : *default_instance_->startpoint_;
}
inline ::FabByExample::proto::symbolic::Point3S* ServoLinePatch::mutable_startpoint() {
  set_has_startpoint();
  if (startpoint_ == NULL) startpoint_ = new ::FabByExample::proto::symbolic::Point3S;
  return startpoint_;
}
inline ::FabByExample::proto::symbolic::Point3S* ServoLinePatch::release_startpoint() {
  clear_has_startpoint();
  ::FabByExample::proto::symbolic::Point3S* temp = startpoint_;
  startpoint_ = NULL;
  return temp;
}
inline void ServoLinePatch::set_allocated_startpoint(::FabByExample::proto::symbolic::Point3S* startpoint) {
  delete startpoint_;
  startpoint_ = startpoint;
  if (startpoint) {
    set_has_startpoint();
  } else {
    clear_has_startpoint();
  }
}

// optional .FabByExample.proto.symbolic.Point3S endPoint = 2;
inline bool ServoLinePatch::has_endpoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServoLinePatch::set_has_endpoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServoLinePatch::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServoLinePatch::clear_endpoint() {
  if (endpoint_ != NULL) endpoint_->::FabByExample::proto::symbolic::Point3S::Clear();
  clear_has_endpoint();
}
inline const ::FabByExample::proto::symbolic::Point3S& ServoLinePatch::endpoint() const {
  return endpoint_ != NULL ? *endpoint_ : *default_instance_->endpoint_;
}
inline ::FabByExample::proto::symbolic::Point3S* ServoLinePatch::mutable_endpoint() {
  set_has_endpoint();
  if (endpoint_ == NULL) endpoint_ = new ::FabByExample::proto::symbolic::Point3S;
  return endpoint_;
}
inline ::FabByExample::proto::symbolic::Point3S* ServoLinePatch::release_endpoint() {
  clear_has_endpoint();
  ::FabByExample::proto::symbolic::Point3S* temp = endpoint_;
  endpoint_ = NULL;
  return temp;
}
inline void ServoLinePatch::set_allocated_endpoint(::FabByExample::proto::symbolic::Point3S* endpoint) {
  delete endpoint_;
  endpoint_ = endpoint;
  if (endpoint) {
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
}

// repeated double normal = 3;
inline int ServoLinePatch::normal_size() const {
  return normal_.size();
}
inline void ServoLinePatch::clear_normal() {
  normal_.Clear();
}
inline double ServoLinePatch::normal(int index) const {
  return normal_.Get(index);
}
inline void ServoLinePatch::set_normal(int index, double value) {
  normal_.Set(index, value);
}
inline void ServoLinePatch::add_normal(double value) {
  normal_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
ServoLinePatch::normal() const {
  return normal_;
}
inline ::google::protobuf::RepeatedField< double >*
ServoLinePatch::mutable_normal() {
  return &normal_;
}

// repeated .FabByExample.proto.ServoSpacingInfo servospacing = 4;
inline int ServoLinePatch::servospacing_size() const {
  return servospacing_.size();
}
inline void ServoLinePatch::clear_servospacing() {
  servospacing_.Clear();
}
inline const ::FabByExample::proto::ServoSpacingInfo& ServoLinePatch::servospacing(int index) const {
  return servospacing_.Get(index);
}
inline ::FabByExample::proto::ServoSpacingInfo* ServoLinePatch::mutable_servospacing(int index) {
  return servospacing_.Mutable(index);
}
inline ::FabByExample::proto::ServoSpacingInfo* ServoLinePatch::add_servospacing() {
  return servospacing_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::ServoSpacingInfo >&
ServoLinePatch::servospacing() const {
  return servospacing_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::ServoSpacingInfo >*
ServoLinePatch::mutable_servospacing() {
  return &servospacing_;
}

// -------------------------------------------------------------------

// PeripheralPatch

// optional int32 edgeId1 = 1;
inline bool PeripheralPatch::has_edgeid1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PeripheralPatch::set_has_edgeid1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PeripheralPatch::clear_has_edgeid1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PeripheralPatch::clear_edgeid1() {
  edgeid1_ = 0;
  clear_has_edgeid1();
}
inline ::google::protobuf::int32 PeripheralPatch::edgeid1() const {
  return edgeid1_;
}
inline void PeripheralPatch::set_edgeid1(::google::protobuf::int32 value) {
  set_has_edgeid1();
  edgeid1_ = value;
}

// optional int32 edgeId2 = 2;
inline bool PeripheralPatch::has_edgeid2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeripheralPatch::set_has_edgeid2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeripheralPatch::clear_has_edgeid2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeripheralPatch::clear_edgeid2() {
  edgeid2_ = 0;
  clear_has_edgeid2();
}
inline ::google::protobuf::int32 PeripheralPatch::edgeid2() const {
  return edgeid2_;
}
inline void PeripheralPatch::set_edgeid2(::google::protobuf::int32 value) {
  set_has_edgeid2();
  edgeid2_ = value;
}

// repeated double normal = 3;
inline int PeripheralPatch::normal_size() const {
  return normal_.size();
}
inline void PeripheralPatch::clear_normal() {
  normal_.Clear();
}
inline double PeripheralPatch::normal(int index) const {
  return normal_.Get(index);
}
inline void PeripheralPatch::set_normal(int index, double value) {
  normal_.Set(index, value);
}
inline void PeripheralPatch::add_normal(double value) {
  normal_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
PeripheralPatch::normal() const {
  return normal_;
}
inline ::google::protobuf::RepeatedField< double >*
PeripheralPatch::mutable_normal() {
  return &normal_;
}

// -------------------------------------------------------------------

// Edge2SPatch

// optional int32 edgeId = 1;
inline bool Edge2SPatch::has_edgeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge2SPatch::set_has_edgeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge2SPatch::clear_has_edgeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge2SPatch::clear_edgeid() {
  edgeid_ = 0;
  clear_has_edgeid();
}
inline ::google::protobuf::int32 Edge2SPatch::edgeid() const {
  return edgeid_;
}
inline void Edge2SPatch::set_edgeid(::google::protobuf::int32 value) {
  set_has_edgeid();
  edgeid_ = value;
}

// -------------------------------------------------------------------

// Connection

// optional int32 parentPatchRef = 1;
inline bool Connection::has_parentpatchref() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connection::set_has_parentpatchref() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connection::clear_has_parentpatchref() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connection::clear_parentpatchref() {
  parentpatchref_ = 0;
  clear_has_parentpatchref();
}
inline ::google::protobuf::int32 Connection::parentpatchref() const {
  return parentpatchref_;
}
inline void Connection::set_parentpatchref(::google::protobuf::int32 value) {
  set_has_parentpatchref();
  parentpatchref_ = value;
}

// repeated int32 patchRef = 2;
inline int Connection::patchref_size() const {
  return patchref_.size();
}
inline void Connection::clear_patchref() {
  patchref_.Clear();
}
inline ::google::protobuf::int32 Connection::patchref(int index) const {
  return patchref_.Get(index);
}
inline void Connection::set_patchref(int index, ::google::protobuf::int32 value) {
  patchref_.Set(index, value);
}
inline void Connection::add_patchref(::google::protobuf::int32 value) {
  patchref_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Connection::patchref() const {
  return patchref_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Connection::mutable_patchref() {
  return &patchref_;
}

// optional .FabByExample.proto.ConnectionMode connectionMode = 3;
inline bool Connection::has_connectionmode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Connection::set_has_connectionmode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Connection::clear_has_connectionmode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Connection::clear_connectionmode() {
  if (connectionmode_ != NULL) connectionmode_->::FabByExample::proto::ConnectionMode::Clear();
  clear_has_connectionmode();
}
inline const ::FabByExample::proto::ConnectionMode& Connection::connectionmode() const {
  return connectionmode_ != NULL ? *connectionmode_ : *default_instance_->connectionmode_;
}
inline ::FabByExample::proto::ConnectionMode* Connection::mutable_connectionmode() {
  set_has_connectionmode();
  if (connectionmode_ == NULL) connectionmode_ = new ::FabByExample::proto::ConnectionMode;
  return connectionmode_;
}
inline ::FabByExample::proto::ConnectionMode* Connection::release_connectionmode() {
  clear_has_connectionmode();
  ::FabByExample::proto::ConnectionMode* temp = connectionmode_;
  connectionmode_ = NULL;
  return temp;
}
inline void Connection::set_allocated_connectionmode(::FabByExample::proto::ConnectionMode* connectionmode) {
  delete connectionmode_;
  connectionmode_ = connectionmode;
  if (connectionmode) {
    set_has_connectionmode();
  } else {
    clear_has_connectionmode();
  }
}

// optional .FabByExample.proto.JointConnection jointConnection = 4;
inline bool Connection::has_jointconnection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Connection::set_has_jointconnection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Connection::clear_has_jointconnection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Connection::clear_jointconnection() {
  if (jointconnection_ != NULL) jointconnection_->::FabByExample::proto::JointConnection::Clear();
  clear_has_jointconnection();
}
inline const ::FabByExample::proto::JointConnection& Connection::jointconnection() const {
  return jointconnection_ != NULL ? *jointconnection_ : *default_instance_->jointconnection_;
}
inline ::FabByExample::proto::JointConnection* Connection::mutable_jointconnection() {
  set_has_jointconnection();
  if (jointconnection_ == NULL) jointconnection_ = new ::FabByExample::proto::JointConnection;
  return jointconnection_;
}
inline ::FabByExample::proto::JointConnection* Connection::release_jointconnection() {
  clear_has_jointconnection();
  ::FabByExample::proto::JointConnection* temp = jointconnection_;
  jointconnection_ = NULL;
  return temp;
}
inline void Connection::set_allocated_jointconnection(::FabByExample::proto::JointConnection* jointconnection) {
  delete jointconnection_;
  jointconnection_ = jointconnection;
  if (jointconnection) {
    set_has_jointconnection();
  } else {
    clear_has_jointconnection();
  }
}

// optional .FabByExample.proto.FillConnection fillConnection = 5;
inline bool Connection::has_fillconnection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Connection::set_has_fillconnection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Connection::clear_has_fillconnection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Connection::clear_fillconnection() {
  if (fillconnection_ != NULL) fillconnection_->::FabByExample::proto::FillConnection::Clear();
  clear_has_fillconnection();
}
inline const ::FabByExample::proto::FillConnection& Connection::fillconnection() const {
  return fillconnection_ != NULL ? *fillconnection_ : *default_instance_->fillconnection_;
}
inline ::FabByExample::proto::FillConnection* Connection::mutable_fillconnection() {
  set_has_fillconnection();
  if (fillconnection_ == NULL) fillconnection_ = new ::FabByExample::proto::FillConnection;
  return fillconnection_;
}
inline ::FabByExample::proto::FillConnection* Connection::release_fillconnection() {
  clear_has_fillconnection();
  ::FabByExample::proto::FillConnection* temp = fillconnection_;
  fillconnection_ = NULL;
  return temp;
}
inline void Connection::set_allocated_fillconnection(::FabByExample::proto::FillConnection* fillconnection) {
  delete fillconnection_;
  fillconnection_ = fillconnection;
  if (fillconnection) {
    set_has_fillconnection();
  } else {
    clear_has_fillconnection();
  }
}

// -------------------------------------------------------------------

// ConnectionMode

// optional .FabByExample.proto.FoldConnection foldConnection = 1;
inline bool ConnectionMode::has_foldconnection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionMode::set_has_foldconnection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectionMode::clear_has_foldconnection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectionMode::clear_foldconnection() {
  if (foldconnection_ != NULL) foldconnection_->::FabByExample::proto::FoldConnection::Clear();
  clear_has_foldconnection();
}
inline const ::FabByExample::proto::FoldConnection& ConnectionMode::foldconnection() const {
  return foldconnection_ != NULL ? *foldconnection_ : *default_instance_->foldconnection_;
}
inline ::FabByExample::proto::FoldConnection* ConnectionMode::mutable_foldconnection() {
  set_has_foldconnection();
  if (foldconnection_ == NULL) foldconnection_ = new ::FabByExample::proto::FoldConnection;
  return foldconnection_;
}
inline ::FabByExample::proto::FoldConnection* ConnectionMode::release_foldconnection() {
  clear_has_foldconnection();
  ::FabByExample::proto::FoldConnection* temp = foldconnection_;
  foldconnection_ = NULL;
  return temp;
}
inline void ConnectionMode::set_allocated_foldconnection(::FabByExample::proto::FoldConnection* foldconnection) {
  delete foldconnection_;
  foldconnection_ = foldconnection;
  if (foldconnection) {
    set_has_foldconnection();
  } else {
    clear_has_foldconnection();
  }
}

// optional .FabByExample.proto.BendConnection bendConnection = 2;
inline bool ConnectionMode::has_bendconnection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectionMode::set_has_bendconnection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectionMode::clear_has_bendconnection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectionMode::clear_bendconnection() {
  if (bendconnection_ != NULL) bendconnection_->::FabByExample::proto::BendConnection::Clear();
  clear_has_bendconnection();
}
inline const ::FabByExample::proto::BendConnection& ConnectionMode::bendconnection() const {
  return bendconnection_ != NULL ? *bendconnection_ : *default_instance_->bendconnection_;
}
inline ::FabByExample::proto::BendConnection* ConnectionMode::mutable_bendconnection() {
  set_has_bendconnection();
  if (bendconnection_ == NULL) bendconnection_ = new ::FabByExample::proto::BendConnection;
  return bendconnection_;
}
inline ::FabByExample::proto::BendConnection* ConnectionMode::release_bendconnection() {
  clear_has_bendconnection();
  ::FabByExample::proto::BendConnection* temp = bendconnection_;
  bendconnection_ = NULL;
  return temp;
}
inline void ConnectionMode::set_allocated_bendconnection(::FabByExample::proto::BendConnection* bendconnection) {
  delete bendconnection_;
  bendconnection_ = bendconnection;
  if (bendconnection) {
    set_has_bendconnection();
  } else {
    clear_has_bendconnection();
  }
}

// optional .FabByExample.proto.FlexConnection flexConnection = 3;
inline bool ConnectionMode::has_flexconnection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectionMode::set_has_flexconnection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectionMode::clear_has_flexconnection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectionMode::clear_flexconnection() {
  if (flexconnection_ != NULL) flexconnection_->::FabByExample::proto::FlexConnection::Clear();
  clear_has_flexconnection();
}
inline const ::FabByExample::proto::FlexConnection& ConnectionMode::flexconnection() const {
  return flexconnection_ != NULL ? *flexconnection_ : *default_instance_->flexconnection_;
}
inline ::FabByExample::proto::FlexConnection* ConnectionMode::mutable_flexconnection() {
  set_has_flexconnection();
  if (flexconnection_ == NULL) flexconnection_ = new ::FabByExample::proto::FlexConnection;
  return flexconnection_;
}
inline ::FabByExample::proto::FlexConnection* ConnectionMode::release_flexconnection() {
  clear_has_flexconnection();
  ::FabByExample::proto::FlexConnection* temp = flexconnection_;
  flexconnection_ = NULL;
  return temp;
}
inline void ConnectionMode::set_allocated_flexconnection(::FabByExample::proto::FlexConnection* flexconnection) {
  delete flexconnection_;
  flexconnection_ = flexconnection;
  if (flexconnection) {
    set_has_flexconnection();
  } else {
    clear_has_flexconnection();
  }
}

// optional .FabByExample.proto.JointConnection jointConnection = 4;
inline bool ConnectionMode::has_jointconnection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectionMode::set_has_jointconnection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectionMode::clear_has_jointconnection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectionMode::clear_jointconnection() {
  if (jointconnection_ != NULL) jointconnection_->::FabByExample::proto::JointConnection::Clear();
  clear_has_jointconnection();
}
inline const ::FabByExample::proto::JointConnection& ConnectionMode::jointconnection() const {
  return jointconnection_ != NULL ? *jointconnection_ : *default_instance_->jointconnection_;
}
inline ::FabByExample::proto::JointConnection* ConnectionMode::mutable_jointconnection() {
  set_has_jointconnection();
  if (jointconnection_ == NULL) jointconnection_ = new ::FabByExample::proto::JointConnection;
  return jointconnection_;
}
inline ::FabByExample::proto::JointConnection* ConnectionMode::release_jointconnection() {
  clear_has_jointconnection();
  ::FabByExample::proto::JointConnection* temp = jointconnection_;
  jointconnection_ = NULL;
  return temp;
}
inline void ConnectionMode::set_allocated_jointconnection(::FabByExample::proto::JointConnection* jointconnection) {
  delete jointconnection_;
  jointconnection_ = jointconnection;
  if (jointconnection) {
    set_has_jointconnection();
  } else {
    clear_has_jointconnection();
  }
}

// -------------------------------------------------------------------

// FoldConnection

// optional double angle = 1;
inline bool FoldConnection::has_angle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FoldConnection::set_has_angle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FoldConnection::clear_has_angle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FoldConnection::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline double FoldConnection::angle() const {
  return angle_;
}
inline void FoldConnection::set_angle(double value) {
  set_has_angle();
  angle_ = value;
}

// -------------------------------------------------------------------

// JointConnection

// optional double angle = 1;
inline bool JointConnection::has_angle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JointConnection::set_has_angle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JointConnection::clear_has_angle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JointConnection::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline double JointConnection::angle() const {
  return angle_;
}
inline void JointConnection::set_angle(double value) {
  set_has_angle();
  angle_ = value;
}

// optional .FabByExample.proto.Articulation articulations = 2;
inline bool JointConnection::has_articulations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JointConnection::set_has_articulations() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JointConnection::clear_has_articulations() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JointConnection::clear_articulations() {
  if (articulations_ != NULL) articulations_->::FabByExample::proto::Articulation::Clear();
  clear_has_articulations();
}
inline const ::FabByExample::proto::Articulation& JointConnection::articulations() const {
  return articulations_ != NULL ? *articulations_ : *default_instance_->articulations_;
}
inline ::FabByExample::proto::Articulation* JointConnection::mutable_articulations() {
  set_has_articulations();
  if (articulations_ == NULL) articulations_ = new ::FabByExample::proto::Articulation;
  return articulations_;
}
inline ::FabByExample::proto::Articulation* JointConnection::release_articulations() {
  clear_has_articulations();
  ::FabByExample::proto::Articulation* temp = articulations_;
  articulations_ = NULL;
  return temp;
}
inline void JointConnection::set_allocated_articulations(::FabByExample::proto::Articulation* articulations) {
  delete articulations_;
  articulations_ = articulations;
  if (articulations) {
    set_has_articulations();
  } else {
    clear_has_articulations();
  }
}

// optional .FabByExample.proto.PrintType printType = 3;
inline bool JointConnection::has_printtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JointConnection::set_has_printtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JointConnection::clear_has_printtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JointConnection::clear_printtype() {
  if (printtype_ != NULL) printtype_->::FabByExample::proto::PrintType::Clear();
  clear_has_printtype();
}
inline const ::FabByExample::proto::PrintType& JointConnection::printtype() const {
  return printtype_ != NULL ? *printtype_ : *default_instance_->printtype_;
}
inline ::FabByExample::proto::PrintType* JointConnection::mutable_printtype() {
  set_has_printtype();
  if (printtype_ == NULL) printtype_ = new ::FabByExample::proto::PrintType;
  return printtype_;
}
inline ::FabByExample::proto::PrintType* JointConnection::release_printtype() {
  clear_has_printtype();
  ::FabByExample::proto::PrintType* temp = printtype_;
  printtype_ = NULL;
  return temp;
}
inline void JointConnection::set_allocated_printtype(::FabByExample::proto::PrintType* printtype) {
  delete printtype_;
  printtype_ = printtype;
  if (printtype) {
    set_has_printtype();
  } else {
    clear_has_printtype();
  }
}

// -------------------------------------------------------------------

// PrintType

// optional bool ballAndSocket = 1;
inline bool PrintType::has_ballandsocket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrintType::set_has_ballandsocket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrintType::clear_has_ballandsocket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrintType::clear_ballandsocket() {
  ballandsocket_ = false;
  clear_has_ballandsocket();
}
inline bool PrintType::ballandsocket() const {
  return ballandsocket_;
}
inline void PrintType::set_ballandsocket(bool value) {
  set_has_ballandsocket();
  ballandsocket_ = value;
}

// optional bool prismatic = 2;
inline bool PrintType::has_prismatic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrintType::set_has_prismatic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrintType::clear_has_prismatic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrintType::clear_prismatic() {
  prismatic_ = false;
  clear_has_prismatic();
}
inline bool PrintType::prismatic() const {
  return prismatic_;
}
inline void PrintType::set_prismatic(bool value) {
  set_has_prismatic();
  prismatic_ = value;
}

// optional bool revolute = 3;
inline bool PrintType::has_revolute() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrintType::set_has_revolute() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrintType::clear_has_revolute() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrintType::clear_revolute() {
  revolute_ = false;
  clear_has_revolute();
}
inline bool PrintType::revolute() const {
  return revolute_;
}
inline void PrintType::set_revolute(bool value) {
  set_has_revolute();
  revolute_ = value;
}

// optional bool none = 4;
inline bool PrintType::has_none() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrintType::set_has_none() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrintType::clear_has_none() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrintType::clear_none() {
  none_ = false;
  clear_has_none();
}
inline bool PrintType::none() const {
  return none_;
}
inline void PrintType::set_none(bool value) {
  set_has_none();
  none_ = value;
}

// -------------------------------------------------------------------

// BendConnection

// optional double angle = 1;
inline bool BendConnection::has_angle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BendConnection::set_has_angle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BendConnection::clear_has_angle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BendConnection::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline double BendConnection::angle() const {
  return angle_;
}
inline void BendConnection::set_angle(double value) {
  set_has_angle();
  angle_ = value;
}

// -------------------------------------------------------------------

// FillConnection

// optional double angle = 1;
inline bool FillConnection::has_angle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FillConnection::set_has_angle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FillConnection::clear_has_angle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FillConnection::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline double FillConnection::angle() const {
  return angle_;
}
inline void FillConnection::set_angle(double value) {
  set_has_angle();
  angle_ = value;
}

// -------------------------------------------------------------------

// FlexConnection

// optional double angle = 1;
inline bool FlexConnection::has_angle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlexConnection::set_has_angle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlexConnection::clear_has_angle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlexConnection::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline double FlexConnection::angle() const {
  return angle_;
}
inline void FlexConnection::set_angle(double value) {
  set_has_angle();
  angle_ = value;
}

// -------------------------------------------------------------------

// MappingFunction

// optional .FabByExample.proto.LinearMappingFunction3 linear_3 = 1;
inline bool MappingFunction::has_linear_3() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MappingFunction::set_has_linear_3() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MappingFunction::clear_has_linear_3() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MappingFunction::clear_linear_3() {
  if (linear_3_ != NULL) linear_3_->::FabByExample::proto::LinearMappingFunction3::Clear();
  clear_has_linear_3();
}
inline const ::FabByExample::proto::LinearMappingFunction3& MappingFunction::linear_3() const {
  return linear_3_ != NULL ? *linear_3_ : *default_instance_->linear_3_;
}
inline ::FabByExample::proto::LinearMappingFunction3* MappingFunction::mutable_linear_3() {
  set_has_linear_3();
  if (linear_3_ == NULL) linear_3_ = new ::FabByExample::proto::LinearMappingFunction3;
  return linear_3_;
}
inline ::FabByExample::proto::LinearMappingFunction3* MappingFunction::release_linear_3() {
  clear_has_linear_3();
  ::FabByExample::proto::LinearMappingFunction3* temp = linear_3_;
  linear_3_ = NULL;
  return temp;
}
inline void MappingFunction::set_allocated_linear_3(::FabByExample::proto::LinearMappingFunction3* linear_3) {
  delete linear_3_;
  linear_3_ = linear_3;
  if (linear_3) {
    set_has_linear_3();
  } else {
    clear_has_linear_3();
  }
}

// optional .FabByExample.proto.LinearMappingFunction2 linear_2 = 2;
inline bool MappingFunction::has_linear_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MappingFunction::set_has_linear_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MappingFunction::clear_has_linear_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MappingFunction::clear_linear_2() {
  if (linear_2_ != NULL) linear_2_->::FabByExample::proto::LinearMappingFunction2::Clear();
  clear_has_linear_2();
}
inline const ::FabByExample::proto::LinearMappingFunction2& MappingFunction::linear_2() const {
  return linear_2_ != NULL ? *linear_2_ : *default_instance_->linear_2_;
}
inline ::FabByExample::proto::LinearMappingFunction2* MappingFunction::mutable_linear_2() {
  set_has_linear_2();
  if (linear_2_ == NULL) linear_2_ = new ::FabByExample::proto::LinearMappingFunction2;
  return linear_2_;
}
inline ::FabByExample::proto::LinearMappingFunction2* MappingFunction::release_linear_2() {
  clear_has_linear_2();
  ::FabByExample::proto::LinearMappingFunction2* temp = linear_2_;
  linear_2_ = NULL;
  return temp;
}
inline void MappingFunction::set_allocated_linear_2(::FabByExample::proto::LinearMappingFunction2* linear_2) {
  delete linear_2_;
  linear_2_ = linear_2;
  if (linear_2) {
    set_has_linear_2();
  } else {
    clear_has_linear_2();
  }
}

// optional .FabByExample.proto.CompositionMappingFunction composition = 3;
inline bool MappingFunction::has_composition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MappingFunction::set_has_composition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MappingFunction::clear_has_composition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MappingFunction::clear_composition() {
  if (composition_ != NULL) composition_->::FabByExample::proto::CompositionMappingFunction::Clear();
  clear_has_composition();
}
inline const ::FabByExample::proto::CompositionMappingFunction& MappingFunction::composition() const {
  return composition_ != NULL ? *composition_ : *default_instance_->composition_;
}
inline ::FabByExample::proto::CompositionMappingFunction* MappingFunction::mutable_composition() {
  set_has_composition();
  if (composition_ == NULL) composition_ = new ::FabByExample::proto::CompositionMappingFunction;
  return composition_;
}
inline ::FabByExample::proto::CompositionMappingFunction* MappingFunction::release_composition() {
  clear_has_composition();
  ::FabByExample::proto::CompositionMappingFunction* temp = composition_;
  composition_ = NULL;
  return temp;
}
inline void MappingFunction::set_allocated_composition(::FabByExample::proto::CompositionMappingFunction* composition) {
  delete composition_;
  composition_ = composition;
  if (composition) {
    set_has_composition();
  } else {
    clear_has_composition();
  }
}

// optional .FabByExample.proto.ExternalMeshAffineMappingFunction external_mesh_affine = 4;
inline bool MappingFunction::has_external_mesh_affine() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MappingFunction::set_has_external_mesh_affine() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MappingFunction::clear_has_external_mesh_affine() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MappingFunction::clear_external_mesh_affine() {
  if (external_mesh_affine_ != NULL) external_mesh_affine_->::FabByExample::proto::ExternalMeshAffineMappingFunction::Clear();
  clear_has_external_mesh_affine();
}
inline const ::FabByExample::proto::ExternalMeshAffineMappingFunction& MappingFunction::external_mesh_affine() const {
  return external_mesh_affine_ != NULL ? *external_mesh_affine_ : *default_instance_->external_mesh_affine_;
}
inline ::FabByExample::proto::ExternalMeshAffineMappingFunction* MappingFunction::mutable_external_mesh_affine() {
  set_has_external_mesh_affine();
  if (external_mesh_affine_ == NULL) external_mesh_affine_ = new ::FabByExample::proto::ExternalMeshAffineMappingFunction;
  return external_mesh_affine_;
}
inline ::FabByExample::proto::ExternalMeshAffineMappingFunction* MappingFunction::release_external_mesh_affine() {
  clear_has_external_mesh_affine();
  ::FabByExample::proto::ExternalMeshAffineMappingFunction* temp = external_mesh_affine_;
  external_mesh_affine_ = NULL;
  return temp;
}
inline void MappingFunction::set_allocated_external_mesh_affine(::FabByExample::proto::ExternalMeshAffineMappingFunction* external_mesh_affine) {
  delete external_mesh_affine_;
  external_mesh_affine_ = external_mesh_affine;
  if (external_mesh_affine) {
    set_has_external_mesh_affine();
  } else {
    clear_has_external_mesh_affine();
  }
}

// optional .FabByExample.proto.ScadMappingFunction scad = 5;
inline bool MappingFunction::has_scad() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MappingFunction::set_has_scad() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MappingFunction::clear_has_scad() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MappingFunction::clear_scad() {
  if (scad_ != NULL) scad_->::FabByExample::proto::ScadMappingFunction::Clear();
  clear_has_scad();
}
inline const ::FabByExample::proto::ScadMappingFunction& MappingFunction::scad() const {
  return scad_ != NULL ? *scad_ : *default_instance_->scad_;
}
inline ::FabByExample::proto::ScadMappingFunction* MappingFunction::mutable_scad() {
  set_has_scad();
  if (scad_ == NULL) scad_ = new ::FabByExample::proto::ScadMappingFunction;
  return scad_;
}
inline ::FabByExample::proto::ScadMappingFunction* MappingFunction::release_scad() {
  clear_has_scad();
  ::FabByExample::proto::ScadMappingFunction* temp = scad_;
  scad_ = NULL;
  return temp;
}
inline void MappingFunction::set_allocated_scad(::FabByExample::proto::ScadMappingFunction* scad) {
  delete scad_;
  scad_ = scad;
  if (scad) {
    set_has_scad();
  } else {
    clear_has_scad();
  }
}

// optional .FabByExample.proto.SymbolicWayPointsMappingFunction symbolicWayPointsMappingFunction = 6;
inline bool MappingFunction::has_symbolicwaypointsmappingfunction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MappingFunction::set_has_symbolicwaypointsmappingfunction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MappingFunction::clear_has_symbolicwaypointsmappingfunction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MappingFunction::clear_symbolicwaypointsmappingfunction() {
  if (symbolicwaypointsmappingfunction_ != NULL) symbolicwaypointsmappingfunction_->::FabByExample::proto::SymbolicWayPointsMappingFunction::Clear();
  clear_has_symbolicwaypointsmappingfunction();
}
inline const ::FabByExample::proto::SymbolicWayPointsMappingFunction& MappingFunction::symbolicwaypointsmappingfunction() const {
  return symbolicwaypointsmappingfunction_ != NULL ? *symbolicwaypointsmappingfunction_ : *default_instance_->symbolicwaypointsmappingfunction_;
}
inline ::FabByExample::proto::SymbolicWayPointsMappingFunction* MappingFunction::mutable_symbolicwaypointsmappingfunction() {
  set_has_symbolicwaypointsmappingfunction();
  if (symbolicwaypointsmappingfunction_ == NULL) symbolicwaypointsmappingfunction_ = new ::FabByExample::proto::SymbolicWayPointsMappingFunction;
  return symbolicwaypointsmappingfunction_;
}
inline ::FabByExample::proto::SymbolicWayPointsMappingFunction* MappingFunction::release_symbolicwaypointsmappingfunction() {
  clear_has_symbolicwaypointsmappingfunction();
  ::FabByExample::proto::SymbolicWayPointsMappingFunction* temp = symbolicwaypointsmappingfunction_;
  symbolicwaypointsmappingfunction_ = NULL;
  return temp;
}
inline void MappingFunction::set_allocated_symbolicwaypointsmappingfunction(::FabByExample::proto::SymbolicWayPointsMappingFunction* symbolicwaypointsmappingfunction) {
  delete symbolicwaypointsmappingfunction_;
  symbolicwaypointsmappingfunction_ = symbolicwaypointsmappingfunction;
  if (symbolicwaypointsmappingfunction) {
    set_has_symbolicwaypointsmappingfunction();
  } else {
    clear_has_symbolicwaypointsmappingfunction();
  }
}

// -------------------------------------------------------------------

// SymbolicWayPointsMappingFunction

// repeated .FabByExample.proto.SymbolicWayPoint symbolicWayPoint = 1;
inline int SymbolicWayPointsMappingFunction::symbolicwaypoint_size() const {
  return symbolicwaypoint_.size();
}
inline void SymbolicWayPointsMappingFunction::clear_symbolicwaypoint() {
  symbolicwaypoint_.Clear();
}
inline const ::FabByExample::proto::SymbolicWayPoint& SymbolicWayPointsMappingFunction::symbolicwaypoint(int index) const {
  return symbolicwaypoint_.Get(index);
}
inline ::FabByExample::proto::SymbolicWayPoint* SymbolicWayPointsMappingFunction::mutable_symbolicwaypoint(int index) {
  return symbolicwaypoint_.Mutable(index);
}
inline ::FabByExample::proto::SymbolicWayPoint* SymbolicWayPointsMappingFunction::add_symbolicwaypoint() {
  return symbolicwaypoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::SymbolicWayPoint >&
SymbolicWayPointsMappingFunction::symbolicwaypoint() const {
  return symbolicwaypoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::SymbolicWayPoint >*
SymbolicWayPointsMappingFunction::mutable_symbolicwaypoint() {
  return &symbolicwaypoint_;
}

// -------------------------------------------------------------------

// SymbolicWayPoint

// optional .FabByExample.proto.symbolic.LinearExpr time = 1;
inline bool SymbolicWayPoint::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolicWayPoint::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolicWayPoint::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolicWayPoint::clear_time() {
  if (time_ != NULL) time_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_time();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& SymbolicWayPoint::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* SymbolicWayPoint::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return time_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* SymbolicWayPoint::release_time() {
  clear_has_time();
  ::FabByExample::proto::symbolic::LinearExpr* temp = time_;
  time_ = NULL;
  return temp;
}
inline void SymbolicWayPoint::set_allocated_time(::FabByExample::proto::symbolic::LinearExpr* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
}

// optional .FabByExample.proto.symbolic.LinearExpr value = 2;
inline bool SymbolicWayPoint::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolicWayPoint::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolicWayPoint::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolicWayPoint::clear_value() {
  if (value_ != NULL) value_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_value();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& SymbolicWayPoint::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* SymbolicWayPoint::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return value_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* SymbolicWayPoint::release_value() {
  clear_has_value();
  ::FabByExample::proto::symbolic::LinearExpr* temp = value_;
  value_ = NULL;
  return temp;
}
inline void SymbolicWayPoint::set_allocated_value(::FabByExample::proto::symbolic::LinearExpr* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// optional bool contact = 3;
inline bool SymbolicWayPoint::has_contact() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolicWayPoint::set_has_contact() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolicWayPoint::clear_has_contact() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolicWayPoint::clear_contact() {
  contact_ = false;
  clear_has_contact();
}
inline bool SymbolicWayPoint::contact() const {
  return contact_;
}
inline void SymbolicWayPoint::set_contact(bool value) {
  set_has_contact();
  contact_ = value;
}

// optional bool ismoving = 4;
inline bool SymbolicWayPoint::has_ismoving() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolicWayPoint::set_has_ismoving() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolicWayPoint::clear_has_ismoving() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolicWayPoint::clear_ismoving() {
  ismoving_ = false;
  clear_has_ismoving();
}
inline bool SymbolicWayPoint::ismoving() const {
  return ismoving_;
}
inline void SymbolicWayPoint::set_ismoving(bool value) {
  set_has_ismoving();
  ismoving_ = value;
}

// -------------------------------------------------------------------

// ScadMappingFunction

// optional string scad_filename = 1;
inline bool ScadMappingFunction::has_scad_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScadMappingFunction::set_has_scad_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScadMappingFunction::clear_has_scad_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScadMappingFunction::clear_scad_filename() {
  if (scad_filename_ != &::google::protobuf::internal::GetEmptyString()) {
    scad_filename_->clear();
  }
  clear_has_scad_filename();
}
inline const ::std::string& ScadMappingFunction::scad_filename() const {
  return *scad_filename_;
}
inline void ScadMappingFunction::set_scad_filename(const ::std::string& value) {
  set_has_scad_filename();
  if (scad_filename_ == &::google::protobuf::internal::GetEmptyString()) {
    scad_filename_ = new ::std::string;
  }
  scad_filename_->assign(value);
}
inline void ScadMappingFunction::set_scad_filename(const char* value) {
  set_has_scad_filename();
  if (scad_filename_ == &::google::protobuf::internal::GetEmptyString()) {
    scad_filename_ = new ::std::string;
  }
  scad_filename_->assign(value);
}
inline void ScadMappingFunction::set_scad_filename(const char* value, size_t size) {
  set_has_scad_filename();
  if (scad_filename_ == &::google::protobuf::internal::GetEmptyString()) {
    scad_filename_ = new ::std::string;
  }
  scad_filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScadMappingFunction::mutable_scad_filename() {
  set_has_scad_filename();
  if (scad_filename_ == &::google::protobuf::internal::GetEmptyString()) {
    scad_filename_ = new ::std::string;
  }
  return scad_filename_;
}
inline ::std::string* ScadMappingFunction::release_scad_filename() {
  clear_has_scad_filename();
  if (scad_filename_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = scad_filename_;
    scad_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ScadMappingFunction::set_allocated_scad_filename(::std::string* scad_filename) {
  if (scad_filename_ != &::google::protobuf::internal::GetEmptyString()) {
    delete scad_filename_;
  }
  if (scad_filename) {
    set_has_scad_filename();
    scad_filename_ = scad_filename;
  } else {
    clear_has_scad_filename();
    scad_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .FabByExample.proto.OpenscadDesign design = 2;
inline bool ScadMappingFunction::has_design() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScadMappingFunction::set_has_design() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScadMappingFunction::clear_has_design() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScadMappingFunction::clear_design() {
  if (design_ != NULL) design_->::FabByExample::proto::OpenscadDesign::Clear();
  clear_has_design();
}
inline const ::FabByExample::proto::OpenscadDesign& ScadMappingFunction::design() const {
  return design_ != NULL ? *design_ : *default_instance_->design_;
}
inline ::FabByExample::proto::OpenscadDesign* ScadMappingFunction::mutable_design() {
  set_has_design();
  if (design_ == NULL) design_ = new ::FabByExample::proto::OpenscadDesign;
  return design_;
}
inline ::FabByExample::proto::OpenscadDesign* ScadMappingFunction::release_design() {
  clear_has_design();
  ::FabByExample::proto::OpenscadDesign* temp = design_;
  design_ = NULL;
  return temp;
}
inline void ScadMappingFunction::set_allocated_design(::FabByExample::proto::OpenscadDesign* design) {
  delete design_;
  design_ = design;
  if (design) {
    set_has_design();
  } else {
    clear_has_design();
  }
}

// -------------------------------------------------------------------

// ExternalMeshAffineMappingFunction

// optional string stl_filename = 1;
inline bool ExternalMeshAffineMappingFunction::has_stl_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExternalMeshAffineMappingFunction::set_has_stl_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExternalMeshAffineMappingFunction::clear_has_stl_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExternalMeshAffineMappingFunction::clear_stl_filename() {
  if (stl_filename_ != &::google::protobuf::internal::GetEmptyString()) {
    stl_filename_->clear();
  }
  clear_has_stl_filename();
}
inline const ::std::string& ExternalMeshAffineMappingFunction::stl_filename() const {
  return *stl_filename_;
}
inline void ExternalMeshAffineMappingFunction::set_stl_filename(const ::std::string& value) {
  set_has_stl_filename();
  if (stl_filename_ == &::google::protobuf::internal::GetEmptyString()) {
    stl_filename_ = new ::std::string;
  }
  stl_filename_->assign(value);
}
inline void ExternalMeshAffineMappingFunction::set_stl_filename(const char* value) {
  set_has_stl_filename();
  if (stl_filename_ == &::google::protobuf::internal::GetEmptyString()) {
    stl_filename_ = new ::std::string;
  }
  stl_filename_->assign(value);
}
inline void ExternalMeshAffineMappingFunction::set_stl_filename(const char* value, size_t size) {
  set_has_stl_filename();
  if (stl_filename_ == &::google::protobuf::internal::GetEmptyString()) {
    stl_filename_ = new ::std::string;
  }
  stl_filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalMeshAffineMappingFunction::mutable_stl_filename() {
  set_has_stl_filename();
  if (stl_filename_ == &::google::protobuf::internal::GetEmptyString()) {
    stl_filename_ = new ::std::string;
  }
  return stl_filename_;
}
inline ::std::string* ExternalMeshAffineMappingFunction::release_stl_filename() {
  clear_has_stl_filename();
  if (stl_filename_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = stl_filename_;
    stl_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ExternalMeshAffineMappingFunction::set_allocated_stl_filename(::std::string* stl_filename) {
  if (stl_filename_ != &::google::protobuf::internal::GetEmptyString()) {
    delete stl_filename_;
  }
  if (stl_filename) {
    set_has_stl_filename();
    stl_filename_ = stl_filename;
  } else {
    clear_has_stl_filename();
    stl_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes stl_data = 2;
inline bool ExternalMeshAffineMappingFunction::has_stl_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExternalMeshAffineMappingFunction::set_has_stl_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExternalMeshAffineMappingFunction::clear_has_stl_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExternalMeshAffineMappingFunction::clear_stl_data() {
  if (stl_data_ != &::google::protobuf::internal::GetEmptyString()) {
    stl_data_->clear();
  }
  clear_has_stl_data();
}
inline const ::std::string& ExternalMeshAffineMappingFunction::stl_data() const {
  return *stl_data_;
}
inline void ExternalMeshAffineMappingFunction::set_stl_data(const ::std::string& value) {
  set_has_stl_data();
  if (stl_data_ == &::google::protobuf::internal::GetEmptyString()) {
    stl_data_ = new ::std::string;
  }
  stl_data_->assign(value);
}
inline void ExternalMeshAffineMappingFunction::set_stl_data(const char* value) {
  set_has_stl_data();
  if (stl_data_ == &::google::protobuf::internal::GetEmptyString()) {
    stl_data_ = new ::std::string;
  }
  stl_data_->assign(value);
}
inline void ExternalMeshAffineMappingFunction::set_stl_data(const void* value, size_t size) {
  set_has_stl_data();
  if (stl_data_ == &::google::protobuf::internal::GetEmptyString()) {
    stl_data_ = new ::std::string;
  }
  stl_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalMeshAffineMappingFunction::mutable_stl_data() {
  set_has_stl_data();
  if (stl_data_ == &::google::protobuf::internal::GetEmptyString()) {
    stl_data_ = new ::std::string;
  }
  return stl_data_;
}
inline ::std::string* ExternalMeshAffineMappingFunction::release_stl_data() {
  clear_has_stl_data();
  if (stl_data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = stl_data_;
    stl_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ExternalMeshAffineMappingFunction::set_allocated_stl_data(::std::string* stl_data) {
  if (stl_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete stl_data_;
  }
  if (stl_data) {
    set_has_stl_data();
    stl_data_ = stl_data;
  } else {
    clear_has_stl_data();
    stl_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .FabByExample.proto.symbolic.AffineMatrix3S transform = 3;
inline bool ExternalMeshAffineMappingFunction::has_transform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExternalMeshAffineMappingFunction::set_has_transform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExternalMeshAffineMappingFunction::clear_has_transform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExternalMeshAffineMappingFunction::clear_transform() {
  if (transform_ != NULL) transform_->::FabByExample::proto::symbolic::AffineMatrix3S::Clear();
  clear_has_transform();
}
inline const ::FabByExample::proto::symbolic::AffineMatrix3S& ExternalMeshAffineMappingFunction::transform() const {
  return transform_ != NULL ? *transform_ : *default_instance_->transform_;
}
inline ::FabByExample::proto::symbolic::AffineMatrix3S* ExternalMeshAffineMappingFunction::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) transform_ = new ::FabByExample::proto::symbolic::AffineMatrix3S;
  return transform_;
}
inline ::FabByExample::proto::symbolic::AffineMatrix3S* ExternalMeshAffineMappingFunction::release_transform() {
  clear_has_transform();
  ::FabByExample::proto::symbolic::AffineMatrix3S* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline void ExternalMeshAffineMappingFunction::set_allocated_transform(::FabByExample::proto::symbolic::AffineMatrix3S* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    set_has_transform();
  } else {
    clear_has_transform();
  }
}

// -------------------------------------------------------------------

// CompositionMappingFunction

// repeated int32 template_id = 1;
inline int CompositionMappingFunction::template_id_size() const {
  return template_id_.size();
}
inline void CompositionMappingFunction::clear_template_id() {
  template_id_.Clear();
}
inline ::google::protobuf::int32 CompositionMappingFunction::template_id(int index) const {
  return template_id_.Get(index);
}
inline void CompositionMappingFunction::set_template_id(int index, ::google::protobuf::int32 value) {
  template_id_.Set(index, value);
}
inline void CompositionMappingFunction::add_template_id(::google::protobuf::int32 value) {
  template_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CompositionMappingFunction::template_id() const {
  return template_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CompositionMappingFunction::mutable_template_id() {
  return &template_id_;
}

// -------------------------------------------------------------------

// LinearMappingFunction3

// optional .FabByExample.proto.symbolic.Mesh3S mesh = 1;
inline bool LinearMappingFunction3::has_mesh() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinearMappingFunction3::set_has_mesh() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinearMappingFunction3::clear_has_mesh() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinearMappingFunction3::clear_mesh() {
  if (mesh_ != NULL) mesh_->::FabByExample::proto::symbolic::Mesh3S::Clear();
  clear_has_mesh();
}
inline const ::FabByExample::proto::symbolic::Mesh3S& LinearMappingFunction3::mesh() const {
  return mesh_ != NULL ? *mesh_ : *default_instance_->mesh_;
}
inline ::FabByExample::proto::symbolic::Mesh3S* LinearMappingFunction3::mutable_mesh() {
  set_has_mesh();
  if (mesh_ == NULL) mesh_ = new ::FabByExample::proto::symbolic::Mesh3S;
  return mesh_;
}
inline ::FabByExample::proto::symbolic::Mesh3S* LinearMappingFunction3::release_mesh() {
  clear_has_mesh();
  ::FabByExample::proto::symbolic::Mesh3S* temp = mesh_;
  mesh_ = NULL;
  return temp;
}
inline void LinearMappingFunction3::set_allocated_mesh(::FabByExample::proto::symbolic::Mesh3S* mesh) {
  delete mesh_;
  mesh_ = mesh;
  if (mesh) {
    set_has_mesh();
  } else {
    clear_has_mesh();
  }
}

// -------------------------------------------------------------------

// LinearMappingFunction2

// optional .FabByExample.proto.symbolic.Drawing2S drawing = 1;
inline bool LinearMappingFunction2::has_drawing() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinearMappingFunction2::set_has_drawing() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinearMappingFunction2::clear_has_drawing() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinearMappingFunction2::clear_drawing() {
  if (drawing_ != NULL) drawing_->::FabByExample::proto::symbolic::Drawing2S::Clear();
  clear_has_drawing();
}
inline const ::FabByExample::proto::symbolic::Drawing2S& LinearMappingFunction2::drawing() const {
  return drawing_ != NULL ? *drawing_ : *default_instance_->drawing_;
}
inline ::FabByExample::proto::symbolic::Drawing2S* LinearMappingFunction2::mutable_drawing() {
  set_has_drawing();
  if (drawing_ == NULL) drawing_ = new ::FabByExample::proto::symbolic::Drawing2S;
  return drawing_;
}
inline ::FabByExample::proto::symbolic::Drawing2S* LinearMappingFunction2::release_drawing() {
  clear_has_drawing();
  ::FabByExample::proto::symbolic::Drawing2S* temp = drawing_;
  drawing_ = NULL;
  return temp;
}
inline void LinearMappingFunction2::set_allocated_drawing(::FabByExample::proto::symbolic::Drawing2S* drawing) {
  delete drawing_;
  drawing_ = drawing;
  if (drawing) {
    set_has_drawing();
  } else {
    clear_has_drawing();
  }
}

// -------------------------------------------------------------------

// FeasibleSet

// optional .FabByExample.proto.ConstraintList constraint_list = 1;
inline bool FeasibleSet::has_constraint_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeasibleSet::set_has_constraint_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeasibleSet::clear_has_constraint_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeasibleSet::clear_constraint_list() {
  if (constraint_list_ != NULL) constraint_list_->::FabByExample::proto::ConstraintList::Clear();
  clear_has_constraint_list();
}
inline const ::FabByExample::proto::ConstraintList& FeasibleSet::constraint_list() const {
  return constraint_list_ != NULL ? *constraint_list_ : *default_instance_->constraint_list_;
}
inline ::FabByExample::proto::ConstraintList* FeasibleSet::mutable_constraint_list() {
  set_has_constraint_list();
  if (constraint_list_ == NULL) constraint_list_ = new ::FabByExample::proto::ConstraintList;
  return constraint_list_;
}
inline ::FabByExample::proto::ConstraintList* FeasibleSet::release_constraint_list() {
  clear_has_constraint_list();
  ::FabByExample::proto::ConstraintList* temp = constraint_list_;
  constraint_list_ = NULL;
  return temp;
}
inline void FeasibleSet::set_allocated_constraint_list(::FabByExample::proto::ConstraintList* constraint_list) {
  delete constraint_list_;
  constraint_list_ = constraint_list;
  if (constraint_list) {
    set_has_constraint_list();
  } else {
    clear_has_constraint_list();
  }
}

// -------------------------------------------------------------------

// ConstraintList

// repeated .FabByExample.proto.Constraint constraint = 1;
inline int ConstraintList::constraint_size() const {
  return constraint_.size();
}
inline void ConstraintList::clear_constraint() {
  constraint_.Clear();
}
inline const ::FabByExample::proto::Constraint& ConstraintList::constraint(int index) const {
  return constraint_.Get(index);
}
inline ::FabByExample::proto::Constraint* ConstraintList::mutable_constraint(int index) {
  return constraint_.Mutable(index);
}
inline ::FabByExample::proto::Constraint* ConstraintList::add_constraint() {
  return constraint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Constraint >&
ConstraintList::constraint() const {
  return constraint_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::Constraint >*
ConstraintList::mutable_constraint() {
  return &constraint_;
}

// repeated int32 inherited_template_id = 2;
inline int ConstraintList::inherited_template_id_size() const {
  return inherited_template_id_.size();
}
inline void ConstraintList::clear_inherited_template_id() {
  inherited_template_id_.Clear();
}
inline ::google::protobuf::int32 ConstraintList::inherited_template_id(int index) const {
  return inherited_template_id_.Get(index);
}
inline void ConstraintList::set_inherited_template_id(int index, ::google::protobuf::int32 value) {
  inherited_template_id_.Set(index, value);
}
inline void ConstraintList::add_inherited_template_id(::google::protobuf::int32 value) {
  inherited_template_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConstraintList::inherited_template_id() const {
  return inherited_template_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConstraintList::mutable_inherited_template_id() {
  return &inherited_template_id_;
}

// -------------------------------------------------------------------

// Constraint

// optional .FabByExample.proto.LinearConstraint linear_constraint = 1;
inline bool Constraint::has_linear_constraint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Constraint::set_has_linear_constraint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Constraint::clear_has_linear_constraint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Constraint::clear_linear_constraint() {
  if (linear_constraint_ != NULL) linear_constraint_->::FabByExample::proto::LinearConstraint::Clear();
  clear_has_linear_constraint();
}
inline const ::FabByExample::proto::LinearConstraint& Constraint::linear_constraint() const {
  return linear_constraint_ != NULL ? *linear_constraint_ : *default_instance_->linear_constraint_;
}
inline ::FabByExample::proto::LinearConstraint* Constraint::mutable_linear_constraint() {
  set_has_linear_constraint();
  if (linear_constraint_ == NULL) linear_constraint_ = new ::FabByExample::proto::LinearConstraint;
  return linear_constraint_;
}
inline ::FabByExample::proto::LinearConstraint* Constraint::release_linear_constraint() {
  clear_has_linear_constraint();
  ::FabByExample::proto::LinearConstraint* temp = linear_constraint_;
  linear_constraint_ = NULL;
  return temp;
}
inline void Constraint::set_allocated_linear_constraint(::FabByExample::proto::LinearConstraint* linear_constraint) {
  delete linear_constraint_;
  linear_constraint_ = linear_constraint;
  if (linear_constraint) {
    set_has_linear_constraint();
  } else {
    clear_has_linear_constraint();
  }
}

// -------------------------------------------------------------------

// LinearConstraint

// optional .FabByExample.proto.symbolic.LinearExpr expr = 1;
inline bool LinearConstraint::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinearConstraint::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinearConstraint::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinearConstraint::clear_expr() {
  if (expr_ != NULL) expr_->::FabByExample::proto::symbolic::LinearExpr::Clear();
  clear_has_expr();
}
inline const ::FabByExample::proto::symbolic::LinearExpr& LinearConstraint::expr() const {
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* LinearConstraint::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::FabByExample::proto::symbolic::LinearExpr;
  return expr_;
}
inline ::FabByExample::proto::symbolic::LinearExpr* LinearConstraint::release_expr() {
  clear_has_expr();
  ::FabByExample::proto::symbolic::LinearExpr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void LinearConstraint::set_allocated_expr(::FabByExample::proto::symbolic::LinearExpr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
}

// optional .FabByExample.proto.LinearConstraint.Type type = 2;
inline bool LinearConstraint::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinearConstraint::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinearConstraint::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinearConstraint::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::FabByExample::proto::LinearConstraint_Type LinearConstraint::type() const {
  return static_cast< ::FabByExample::proto::LinearConstraint_Type >(type_);
}
inline void LinearConstraint::set_type(::FabByExample::proto::LinearConstraint_Type value) {
  assert(::FabByExample::proto::LinearConstraint_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .FabByExample.proto.LinearConstraint.ConstraintSemantics constraintSemantics = 3;
inline bool LinearConstraint::has_constraintsemantics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinearConstraint::set_has_constraintsemantics() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinearConstraint::clear_has_constraintsemantics() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinearConstraint::clear_constraintsemantics() {
  constraintsemantics_ = 1;
  clear_has_constraintsemantics();
}
inline ::FabByExample::proto::LinearConstraint_ConstraintSemantics LinearConstraint::constraintsemantics() const {
  return static_cast< ::FabByExample::proto::LinearConstraint_ConstraintSemantics >(constraintsemantics_);
}
inline void LinearConstraint::set_constraintsemantics(::FabByExample::proto::LinearConstraint_ConstraintSemantics value) {
  assert(::FabByExample::proto::LinearConstraint_ConstraintSemantics_IsValid(value));
  set_has_constraintsemantics();
  constraintsemantics_ = value;
}

// -------------------------------------------------------------------

// Articulation

// repeated .FabByExample.proto.symbolic.Transform transforms = 1;
inline int Articulation::transforms_size() const {
  return transforms_.size();
}
inline void Articulation::clear_transforms() {
  transforms_.Clear();
}
inline const ::FabByExample::proto::symbolic::Transform& Articulation::transforms(int index) const {
  return transforms_.Get(index);
}
inline ::FabByExample::proto::symbolic::Transform* Articulation::mutable_transforms(int index) {
  return transforms_.Mutable(index);
}
inline ::FabByExample::proto::symbolic::Transform* Articulation::add_transforms() {
  return transforms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Transform >&
Articulation::transforms() const {
  return transforms_;
}
inline ::google::protobuf::RepeatedPtrField< ::FabByExample::proto::symbolic::Transform >*
Articulation::mutable_transforms() {
  return &transforms_;
}

// optional .FabByExample.proto.symbolic.Point3S center = 2;
inline bool Articulation::has_center() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Articulation::set_has_center() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Articulation::clear_has_center() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Articulation::clear_center() {
  if (center_ != NULL) center_->::FabByExample::proto::symbolic::Point3S::Clear();
  clear_has_center();
}
inline const ::FabByExample::proto::symbolic::Point3S& Articulation::center() const {
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::FabByExample::proto::symbolic::Point3S* Articulation::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::FabByExample::proto::symbolic::Point3S;
  return center_;
}
inline ::FabByExample::proto::symbolic::Point3S* Articulation::release_center() {
  clear_has_center();
  ::FabByExample::proto::symbolic::Point3S* temp = center_;
  center_ = NULL;
  return temp;
}
inline void Articulation::set_allocated_center(::FabByExample::proto::symbolic::Point3S* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace FabByExample

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FabByExample::proto::Semantics_PrintMethod>() {
  return ::FabByExample::proto::Semantics_PrintMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FabByExample::proto::Semantics_PartType>() {
  return ::FabByExample::proto::Semantics_PartType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FabByExample::proto::LinearConstraint_ConstraintSemantics>() {
  return ::FabByExample::proto::LinearConstraint_ConstraintSemantics_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FabByExample::proto::LinearConstraint_Type>() {
  return ::FabByExample::proto::LinearConstraint_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_template_2eproto__INCLUDED
